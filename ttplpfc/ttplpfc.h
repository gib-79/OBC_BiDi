//#############################################################################
//
// FILE:   ttplpfc.h
//
// TITLE: This is the solution header file.
//
//#############################################################################
// $TI Release: obc_7_4kw_ttplpfc_clllc v1.00.01.00 $
// $Release Date: Fri Dec 16 18:13:38 CST 2022 $
// $Copyright:
// Copyright (C) 2022 Texas Instruments Incorporated - http://www.ti.com/
//
// ALL RIGHTS RESERVED
// $
//#############################################################################

#ifndef TTPLPFC_H
#define TTPLPFC_H

#ifdef __cplusplus

extern "C" {
#endif

//
// the includes & defines
//
#include <stdint.h>
#include <stddef.h>

#ifndef __TMS320C28XX_CLA__
#include <math.h>
#else
#include <CLAmath.h>
#endif

// this is the file generated by the powerSUITE page for this system
#include <ttplpfc_settings.h>
#include "ttplpfc_hal.h"
#if TTPLPFC_AEF_ENABLED == 1
#include "aef.h"
#endif
//
// Library header files
// DCL Library is used for the controller implementation
// GI -> series form of DCL_PI for current loop (gi),
// GV -> parallel form of DCL_PI for voltage loop (gv),
// NOTCH_2P2Z -> notch filter using DCL_DF22 which implements a 2p2z structure
//
#ifndef __TMS320C28XX_CLA__
#include "DCLF32.h"
#define TTPLPFC_GI_STRUCT DCL_PI
//
// GI on C28x ,run DCL_PI routine written in assembly
//
#define TTPLPFC_GI_RUN DCL_runPI_C1
#define TTPLPFC_GV_STRUCT DCL_PI

//
// gv on C28x, run DCL_PI routine written in assembly
//
#define TTPLPFC_GV_RUN DCL_runPI_C4
#define TTPLPFC_NOTCH_2P2Z_STRUCT DCL_DF22

//
// notch filter on C28x, run DCL_DF22 routine written in assembly
//
#define TTPLPFC_NOTCH_2P2Z_RUN DCL_runDF22_C1
#else
#include "DCLCLA.h"

//
//GI
//
#define TTPLPFC_GI_STRUCT DCL_PI_CLA

//
// GI on CLA, run DCL_PI routine written in CLA assembly
//
#define TTPLPFC_GI_RUN DCL_runPI_L1

#define TTPLPFC_GV_STRUCT DCL_PI_CLA

//
// gv on CLA, run DCL_PI routine written as inline function
// because it is called in the background task
//
#define TTPLPFC_GV_RUN DCL_runPI_L4

#define TTPLPFC_NOTCH_2P2Z_STRUCT DCL_DF22_CLA

//
// notch filter on CLA, run DCL_DF22 routine written as inline function
// because it is called in the background task
//
#define TTPLPFC_NOTCH_2P2Z_RUN DCL_runDF22_L4

#pragma FUNC_ALWAYS_INLINE(DCL_runDF22_L4)
#pragma FUNC_ALWAYS_INLINE(CLAsqrt_inline)

#define TTPLPFC_PR_CNTL_STRUCT DCL_DF22_CLA

#endif

#include "dlog_4ch.h"
#include "rampgen.h"
#include "spll_1ph_sogi.h"
#include "spll_1ph_notch.h"
#include "spll_1ph_sogi_fll.h"
#include "power_meas_sine_analyzer.h"
#pragma FUNC_ALWAYS_INLINE(POWER_MEAS_SINE_ANALYZER_run)
#pragma FUNC_ALWAYS_INLINE(EPWM_setActionQualifierContSWForceAction)


#ifndef __TMS320C28XX_CLA__
#include "sfra_f32.h"
#include "sfra_gui_scicomms_driverlib.h"
#else
#define SFRA_F32_inject(m)    m
#define SFRA_F32_collect(m,n)
#endif

#define TTPLPFC_PWM_SWITCHING_NZC1 ((float32_t)0.02)
#define TTPLPFC_PWM_SWITCHING_NZC2 ((float32_t)-0.02)

#define TTPLPFC_PWM_SWITCHING_PZC1 ((float32_t)-0.035)
#define TTPLPFC_PWM_SWITCHING_PZC2 ((float32_t)0.0)

#define TTPLPFC_EMAVG_MACRO(in, out, multiplier) out =                         \
        ((in - out) * multiplier) + out;

//
// System Settings
//

//
//Add any system specific setting below
//
#if TTPLPFC_SFRA_TYPE == TTPLPFC_SFRA_VOLTAGE

#define TTPLPFC_SFRA_FREQ_START 2
#define TTPLPFC_SFRA_FREQ_LENGTH 30

//
//SFRA step Multiply = 10^(1/No of steps per decade(40))
//
#define TTPLPFC_SFRA_FREQ_STEP_MULTIPLY ((float32_t)1.08)
#define TTPLPFC_SFRA_AMPLITUDE ((float32_t)0.005)

#elif TTPLPFC_SFRA_TYPE == TTPLPFC_SFRA_CURRENT

#if TTPLPFC_DC_CHECK == 1
#define TTPLPFC_SFRA_FREQ_START 30

//
//SFRA step Multiply = 10^(1/No of steps per decade(40))
//
#define TTPLPFC_SFRA_FREQ_STEP_MULTIPLY ((float32_t)1.07)
#define TTPLPFC_SFRA_AMPLITUDE ((float32_t)0.005)
#else
#define TTPLPFC_SFRA_FREQ_START 0.2

//
//SFRA step Multiply = 10^(1/No of steps per decade(40))
//
#define TTPLPFC_SFRA_FREQ_STEP_MULTIPLY ((float32_t)1.052)
#define TTPLPFC_SFRA_AMPLITUDE ((float32_t)0.01)
#endif

#define TTPLPFC_SFRA_FREQ_LENGTH 100

#endif

#define TTPLPFC_GRID_MAX_FREQ 70
#define TTPLPFC_GRID_MIN_FREQ 40


//
// typedefs
//
typedef union{
    enum
    {
        TTPLPFC_Lab1 = 0,
        TTPLPFC_Lab2 = 1,
        TTPLPFC_Lab3 = 2,
        TTPLPFC_Lab4 = 3,
        TTPLPFC_Lab5 = 4,
        TTPLPFC_Lab6 = 5,
        TTPLPFC_Lab7 = 6,
        TTPLPFC_Lab8 = 7,
        TTPLPFC_Lab9 = 8,
        TTPLPFC_Lab1_CLA = 9,
        TTPLPFC_Lab2_CLA = 10,
        TTPLPFC_Lab3_CLA = 11,
        TTPLPFC_Lab4_CLA = 12,
        TTPLPFC_Lab5_CLA = 13,
        TTPLPFC_Lab6_CLA = 14,
        TTPLPFC_Lab7_CLA = 15,
        TTPLPFC_Lab8_CLA = 16,
        TTPLPFC_Lab9_CLA = 17,
    }enum_lab;
    int32_t pad;
}TTPLPFC_Lab_EnumType;

extern TTPLPFC_Lab_EnumType TTPLPFC_lab;

typedef union{
    enum
    {
        boardState_OFF = 0,
        boardState_CheckACInput = 1,
        boardState_RlyConnect = 2,
        boardState_PowerStageON = 3,
        boardState_TripCondition = 4,
    }enum_boardState;
    int32_t pad;
}TTPLPFC_boardState;

extern TTPLPFC_boardState TTPLPFC_board_State;

typedef union{
    enum
    {
        boardStatus_Idle = 0,
        boardStatus_NoFault = 1,
        boardStatus_OverCurrentTrip_Ph1_H = 2,
        boardStatus_OverCurrentTrip_Ph1_L = 3,
        boardStatus_OverCurrentTrip_Ph2_H = 4,
        boardStatus_OverCurrentTrip_Ph2_L = 5,
        boardStatus_EmulatorStopTrip = 6,
        boardStatus_OverVoltageTrip = 7,
        boardStatus_InputUnderVoltageTrip = 8,
        boardStatus_NoGridConnection = 9,
        boardStatus_FAULTn = 10,
    }enum_boardStatus;
    int32_t pad;
}TTPLPFC_boardStatus;

extern TTPLPFC_boardStatus TTPLPFC_board_Status;

typedef union{
    enum
    {
        pwmSwState_normalOperation = 0,
        pwmSwState_positiveHalf = 1,
        pwmSwState_negativeZeroCrossing1 = 2,
        pwmSwState_negativeZeroCrossing2 = 3,
        pwmSwState_negativeZeroCrossing3 = 4,
        pwmSwState_negativeHalf = 5,
        pwmSwState_positiveZeroCrossing1 = 6,
        pwmSwState_positiveZeroCrossing2 = 7,
        pwmSwState_positiveZeroCrossing3 = 8,
        pwmSwState_defaultState = 9,
    }enum_pwmSwState;
    int32_t pad;
}TTPLPFC_pwmSwState;

extern TTPLPFC_pwmSwState TTPLPFC_pwm_SwState;

typedef union{
    enum
    {
        interleavingState_1ph = 0,
        interleavingState_2ph = 1,
        interleavingState_3ph = 2,
    }enum_interleavingState;
    int32_t pad;
}TTPLPFC_interleavingState;

extern TTPLPFC_interleavingState TTPLPFC_interleaving_State;

//
// globals
//

//
// RAMP to generate forced angle when grid is not present
//
extern RAMPGEN TTPLPFC_rgen;

//
// current controller
//
extern float32_t TTPLPFC_gi1_out_ff_scale;
extern TTPLPFC_GI_STRUCT TTPLPFC_gi1;
extern TTPLPFC_GI_STRUCT TTPLPFC_gi2;
extern float32_t TTPLPFC_gi_Kp;
extern float32_t TTPLPFC_gi_Ki;
extern float32_t TTPLPFC_gi_Kp_Ref;
extern float32_t TTPLPFC_gi_Ki_Ref;
extern uint32_t TTPLPFC_updateCoefficientsCommand;

//
// voltage controller
//
extern TTPLPFC_GV_STRUCT TTPLPFC_gv;

extern SPLL_1PH_SOGI TTPLPFC_spll1;
extern SPLL_1PH_NOTCH TTPLPFC_spll2;
extern SPLL_1PH_SOGI_FLL TTPLPFC_spll3;

extern TTPLPFC_NOTCH_2P2Z_STRUCT TTPLPFC_notch1;
extern TTPLPFC_NOTCH_2P2Z_STRUCT TTPLPFC_notch2;

extern TTPLPFC_NOTCH_2P2Z_STRUCT TTPLPFC_spll_notch_50Hz;
extern TTPLPFC_NOTCH_2P2Z_STRUCT TTPLPFC_spll_notch_60Hz;

extern uint16_t TTPLPFC_guiPowerStageStart;
extern uint16_t TTPLPFC_guiPowerStageStop;

#if TTPLPFC_SFRA_TYPE != TTPLPFC_SFRA_DISABLED
extern float32_t TTPLPFC_plantMagVect[TTPLPFC_SFRA_FREQ_LENGTH];
extern float32_t plantPhaseVect[TTPLPFC_SFRA_FREQ_LENGTH];
extern float32_t olMagVect[TTPLPFC_SFRA_FREQ_LENGTH];
extern float32_t olPhaseVect[TTPLPFC_SFRA_FREQ_LENGTH];
extern float32_t freqVect[TTPLPFC_SFRA_FREQ_LENGTH];
#endif

extern float32_t TTPLPFC_iL1_sensed_pu;
extern float32_t TTPLPFC_iL2_sensed_pu;
extern float32_t TTPLPFC_iL3_sensed_pu;
extern float32_t TTPLPFC_iL1_sensed_Amps;
extern float32_t TTPLPFC_iL2_sensed_Amps;
extern float32_t TTPLPFC_iL3_sensed_Amps;
extern float32_t TTPLPFC_iL1_senseOffset_pu;
extern float32_t TTPLPFC_iL2_senseOffset_pu;
extern float32_t TTPLPFC_iL3_senseOffset_pu;

//
// AC Current Measurement
//
extern float32_t TTPLPFC_ac_cur_sensed_pu;
extern float32_t TTPLPFC_ac_cur_sensed_Amps;
extern float32_t TTPLPFC_ac_cur_senseOffset_pu;

//
// AC Grid Sync offset
//
extern float32_t TTPLPFC_thetaOffset_pu;

//
// Output Voltage measurement
//

//chang next lines to *retain* instead of volatile all the way to 528 should be OK. previous volatiles too.
extern float32_t TTPLPFC_vBus_sensed_pu;
extern float32_t TTPLPFC_vBus_sensedOffset_pu;
extern float32_t TTPLPFC_vBus_sensed_Volts;

//
//Input voltage measurement
//
extern float32_t TTPLPFC_ac_L_sensed_pu;
extern float32_t TTPLPFC_ac_N_sensed_pu;
extern float32_t TTPLPFC_ac_vol_sensed_pu;
extern float32_t TTPLPFC_ac_vol_sensed_Volts;
extern float32_t TTPLPFC_ac_L_senseOffset_pu;
extern float32_t TTPLPFC_ac_N_senseOffset_pu;

extern float32_t TTPLPFC_ac_vol_senseOffset_pu;
extern float32_t TTPLPFC_system_temp_pu;
extern float32_t TTPLPFC_system_vref_165_pu;
extern float32_t TTPLPFC_vbus2_pu;

//
// Filtered DC bus measurement
//
extern float32_t TTPLPFC_vBusAvg_pu;
extern float32_t TTPLPFC_vRmsAvg_pu;

extern uint32_t TTPLPFC_dbRED_SetValue_ticks;
extern uint32_t TTPLPFC_dbRED_SetValue_Temp_ticks;
extern uint32_t TTPLPFC_dbFED_SetValue_ticks;
extern uint32_t TTPLPFC_dbRED_SetValue1_ticks;
extern uint32_t TTPLPFC_dbRED_SetValue_Temp1_ticks;
extern uint32_t TTPLPFC_dbRED_SetValue2_ticks;
extern uint32_t TTPLPFC_dbRED_SetValue_Temp2_ticks;
extern uint32_t TTPLPFC_dbRED_SetValue3_ticks;
extern uint32_t TTPLPFC_dbRED_SetValue_Temp3_ticks;
extern uint32_t TTPLPFC_dbRED_Min_ticks;
extern uint32_t TTPLPFC_dbRED_Max_ticks;

extern float32_t TTPLPFC_softstart_duty;
extern float32_t TTPLPFC_softStartDeadbandScalingFactor;

//
// Reference variables
//

//
//  current set point
//
extern float32_t TTPLPFC_ac_cur_ref_pu;
extern float32_t TTPLPFC_ac_cur_ref_inst_pu;
extern float32_t TTPLPFC_ac_cur_ref_inst_prev_pu;
extern float32_t TTPLPFC_inductor_voltage_drop_feedforward;

//
// voltage set point
//
extern float32_t TTPLPFC_vBusRef_pu;
extern float32_t TTPLPFC_vBusRefSlewed_pu;

//
// Display Values
//
extern float32_t TTPLPFC_vBus_overVoltage_Volts;
extern float32_t TTPLPFC_vBus_underVoltage_Volts;
extern float32_t TTPLPFC_powerRms_Watts;
extern float32_t TTPLPFC_ac_curRms_sensed_Amps;
extern float32_t TTPLPFC_ac_volRms_sensed_Volts;
extern float32_t TTPLPFC_ac_volRms_overVoltage_Volts;
extern float32_t TTPLPFC_ac_volRms_underVoltage_Volts;
extern float32_t TTPLPFC_powerFactor;
extern float32_t TTPLPFC_apparentPower_VA;
extern float32_t TTPLPFC_acFreqAvg_Hz;
extern float32_t TTPLPFC_ac_volEma_sensed_Volts;
extern float32_t TTPLPFC_ac_volRmsEma_sensed_Volts;
extern int32_t TTPLPFC_autoStartSlew;

//
// Phase-Shedding Variables
//
extern float32_t TTPLPFC_iref1_pu;
extern float32_t TTPLPFC_iref2_pu;
extern float32_t TTPLPFC_deltaIref_pu;

//
// Variables used to calibrate measurement offsets
//Offset filter coefficient K1: 0.05/(T+0.05);
//
extern float32_t k1;

//
//Offset filter coefficient K2: T/(T+0.05)
//
extern float32_t k2;
extern int16_t offsetCalCounter;
extern float32_t offset165;


//
// Duty variables for inverter (per unit and compare register values)
// per unit duty value
//
extern float32_t TTPLPFC_duty1_pu;
extern float32_t TTPLPFC_duty2_pu;
extern float32_t TTPLPFC_duty_clamp_high_pu;
extern float32_t TTPLPFC_duty_clamp_low_pu;
extern float32_t TTPLPFC_duty_DC_ref_pu;
extern float32_t TTPLPFC_duty_DC_ref_final_pu;
extern float32_t TTPLPFC_duty_ref_pu;

//
// Flags for clearing trips and closing the loops and the Relay
//
extern int32_t TTPLPFC_closeGiLoop;
extern int32_t TTPLPFC_closeGvLoop;
extern int32_t TTPLPFC_clearTrip;
extern int32_t TTPLPFC_rlyConnect;
extern int32_t TTPLPFC_firstTimeGvLoop;

//
// Flags for detecting ZCD
//
extern float32_t TTPLPFC_acSine;
extern float32_t TTPLPFC_acSinePrev;
extern float32_t TTPLPFC_acCosine;
extern float32_t TTPLPFC_acCosinePrev;
extern int32_t TTPLPFC_zeroCrossDetectFlag;

extern int32_t TTPLPFC_state_slew;
extern int32_t TTPLPFC_state_slew_max;

extern float32_t TTPLPFC_gi1_out;
extern float32_t TTPLPFC_gi2_out;
extern float32_t TTPLPFC_gv_out;

extern float32_t TTPLPFC_phase1ScaleFactor;
extern float32_t TTPLPFC_phase2ScaleFactor;
extern float32_t TTPLPFC_phase3ScaleFactor;

////
//// Variable to log how many times ISR1 is nested from
////
extern int32_t TTPLPFC_ISR1_nestingCounter;
extern int32_t TTPLPFC_ISR1_nests;
extern int32_t TTPLPFC_ISR1_nestsMax;
extern float32_t TTPLPFC_ISR1_nestsAvg;

//
// eCAP Profiling related variables
//

//
// Variables to log the capture value for profiling ISR1
//
extern uint32_t  TTPLPFC_ISR1cap1Count;
extern uint32_t  TTPLPFC_ISR1cap2Count;
extern uint32_t  TTPLPFC_ISR1cap3Count;
extern uint32_t  TTPLPFC_ISR1cap4Count;

//
// Variable for logging the the max value and also computing the average for ISR1
//
extern uint32_t TTPLPFC_ISR1_capCountMax;
extern float32_t TTPLPFC_ISR1cap1CountAvg;
extern float32_t TTPLPFC_ISR2_LoadingAvg_accountingForNesting;

//
// Variables to compute the loading percentage for ISR1
//
extern float32_t TTPLPFC_ISR1_Loading;
extern float32_t TTPLPFC_ISR1_LoadingMax;

//
// Variables to log the capture value for profiling ISR2
//
extern uint32_t  TTPLPFC_ISR2cap1Count;
extern uint32_t  TTPLPFC_ISR2cap2Count;
extern uint32_t  TTPLPFC_ISR2cap3Count;
extern uint32_t  TTPLPFC_ISR2cap4Count;

//
// Variables to compute the loading percentage for ISR2
// subtracts the ISR1 nesting cycles
//
extern float32_t TTPLPFC_ISR2_Loading;
extern float32_t TTPLPFC_ISR2_LoadingAvg;

//
// Sine analyzer block for RMS Volt, Curr and Power measurements
//
extern POWER_MEAS_SINE_ANALYZER TTPLPFC_sine_mains;

#ifndef __TMS320C28XX_CLA__
//
// datalogger
//
extern DLOG_4CH TTPLPFC_dLog1;
extern float32_t TTPLPFC_dBuff1[100];
extern float32_t TTPLPFC_dBuff2[100];
extern float32_t TTPLPFC_dBuff3[100];
extern float32_t TTPLPFC_dBuff4[100];
extern float32_t TTPLPFC_dVal1;
extern float32_t TTPLPFC_dVal2;
extern float32_t TTPLPFC_dVal3;
extern float32_t TTPLPFC_dVal4;
#endif

extern float32_t TTPLPFC_vBusSensedBuff[10];
extern float32_t TTPLPFC_vBus_sensedFiltered;
extern int32_t TTPLPFC_vBusSensedBuffIndex;

extern float32_t TTPLPFC_vBus_sensedFiltered_notch1;
extern float32_t TTPLPFC_vBus_sensedFiltered_notch2;

extern float32_t TTPLPFC_threshold_PZC1;
extern float32_t TTPLPFC_threshold_PZC2;
extern float32_t TTPLPFC_threshold_NZC1;
extern float32_t TTPLPFC_threshold_NZC2;

extern float32_t TTPLPFC_ac_vol_sensed_buff[5];
extern int32_t TTPLPFC_ac_vol_sensed_buff_index;
extern int32_t TTPLPFC_ac_sign_filtered;

extern float32_t TTPLPFC_spll_sine;
extern float32_t TTPLPFC_spll_cosine;
extern float32_t TTPLPFC_voltage_error;

//
// 1 if using non linear voltage loop, 0 otherwise
//
extern uint32_t TTPLPFC_nonLinearVoltageLoopFlag;

extern uint32_t TTPLPFC_softStartDeadBandFED;

extern uint32_t TTPLPFC_manualStop;
extern uint32_t TTPLPFC_timedRun_flag;
extern float32_t TTPLPFC_timedRun_ms;
extern float32_t TTPLPFC_timedRunCounter_ms;
extern float32_t TTPLPFC_dutySlew_pu;

#ifndef __TMS320C28XX_CLA__
void TTPLPFC_setupSFRA();
void TTPLPFC_globalVariablesInit();
#else
#endif

//
// the function prototypes
//

void TTPLPFC_runSFRABackGroundTasks(void);

void TTPLPFC_setLabIndicatorVariable(void);

void TTPLPFC_autoStart(void);

void TTPLPFC_updateBoardStatus(void);

static inline void TTPLPFC_detectZeroCrossingClearPWMTrip(
                uint32_t base1, uint32_t base2, uint32_t base3, uint32_t base4);

void TTPLPFC_computeNotchFltrCoeff(TTPLPFC_NOTCH_2P2Z_STRUCT *coeff,
                float32_t Fs, float32_t notch_freq, float32_t c1, float32_t c2);

void TTPLPFC_runCoefficientsUpdate(void);

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_read_acReturnCurrent)
static inline void TTPLPFC_read_acReturnCurrent()
{

    //
    //
    //
//    TTPLPFC_ac_cur_sensed_pu =  (((float32_t)(TTPLPFC_AC_CUR_FB +
//                                TTPLPFC_AC_CUR_FB_2 +  TTPLPFC_AC_CUR_FB_3))
//                                * 0.333 * TTPLPFC_ADC_PU_SCALE_FACTOR
//                                - (TTPLPFC_ac_cur_senseOffset_pu)) * -2.0f;
}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_read_acVoltage_separateResistor)
static inline void TTPLPFC_read_acVoltage_separateResistor()
{
//    TTPLPFC_ac_L_sensed_pu = (((float32_t)(TTPLPFC_AC_L_FB +
//            TTPLPFC_AC_L_FB_2 + TTPLPFC_AC_L_FB_3 ) * 0.333f *
//            TTPLPFC_ADC_PU_SCALE_FACTOR));
//    TTPLPFC_ac_N_sensed_pu = (((float32_t) (TTPLPFC_AC_N_FB +
//            TTPLPFC_AC_N_FB_2 + TTPLPFC_AC_N_FB_3 ) * 0.333f *
//            TTPLPFC_ADC_PU_SCALE_FACTOR));
//    TTPLPFC_ac_vol_sensed_pu = TTPLPFC_ac_L_sensed_pu -
//                TTPLPFC_ac_N_sensed_pu - TTPLPFC_ac_vol_senseOffset_pu;

    TTPLPFC_ac_L_sensed_pu = (((float32_t)TTPLPFC_AC_L_FB *
            TTPLPFC_ADC_PU_SCALE_FACTOR));
    TTPLPFC_ac_N_sensed_pu = (((float32_t)TTPLPFC_AC_N_FB *
            TTPLPFC_ADC_PU_SCALE_FACTOR));

}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_read_acVoltage)
static inline void TTPLPFC_read_acVoltage()
{

    TTPLPFC_ac_vol_sensed_pu =  (((float32_t)(TTPLPFC_VAC_FB + TTPLPFC_VAC_FB_2) * TTPLPFC_ADC_PU_SCALE_FACTOR * (float32_t)0.5)
            - TTPLPFC_ac_vol_senseOffset_pu ) * (float32_t)2.0;

}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_read_systemSignals)
static inline void TTPLPFC_read_systemSignals()
{

    TTPLPFC_system_temp_pu =  ((float32_t)(TTPLPFC_SYSTEM_TEMP_FB) * TTPLPFC_ADC_PU_SCALE_FACTOR);
    TTPLPFC_system_vref_165_pu =  ((float32_t)(TTPLPFC_SYSTEM_VREF_165_FB) * TTPLPFC_ADC_PU_SCALE_FACTOR);
    TTPLPFC_vbus2_pu =  ((float32_t)(TTPLPFC_VBUS2_FB) * TTPLPFC_ADC_PU_SCALE_FACTOR);
}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_read_individualCurrent)
static inline void TTPLPFC_read_individualCurrent()
{
    //
    // Rev E2 the iL1 and iL2 are swapped hence the swap on the below read of the ADC signals
    //
    TTPLPFC_iL2_sensed_pu = (((float32_t)(TTPLPFC_IL1_FB + TTPLPFC_IL1_FB_2) * (float32_t)0.5 *
            TTPLPFC_ADC_PU_SCALE_FACTOR - TTPLPFC_iL2_senseOffset_pu)) * 2.0f;
    TTPLPFC_iL1_sensed_pu = (((float32_t)(TTPLPFC_IL2_FB + TTPLPFC_IL2_FB_2) * (float32_t)0.5 *
            TTPLPFC_ADC_PU_SCALE_FACTOR - TTPLPFC_iL1_senseOffset_pu)) * 2.0f;

#if TTPLPFC_TOTAL_NO_PHASES == 3
    TTPLPFC_iL3_sensed_pu = (((float32_t)(TTPLPFC_IL3_FB ) *
            TTPLPFC_ADC_PU_SCALE_FACTOR - TTPLPFC_iL3_senseOffset_pu)) * 2.0f;
#endif
}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_read_busVoltage)
static inline void TTPLPFC_read_busVoltage()
{
    TTPLPFC_vBus_sensed_pu = ((float32_t)(TTPLPFC_VBUS_FB  +
            TTPLPFC_VBUS_FB_2 ) *
            TTPLPFC_ADC_PU_SCALE_FACTOR * (1.0f / 2.0f));
}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_rampGenerate)
static inline void TTPLPFC_rampGenerate()
{
    RAMPGEN_run(&TTPLPFC_rgen);

    //
    // Use the angle value to compute the sine value
    //
    TTPLPFC_acSinePrev = TTPLPFC_acSine;
    TTPLPFC_acSine = sinf(TTPLPFC_rgen.out * ((float32_t) 6.283185307));
    TTPLPFC_acCosine = cosf(TTPLPFC_rgen.out * ((float32_t) 6.283185307));

    if(TTPLPFC_acSine > 0.0)
    {
       TTPLPFC_ac_sign_filtered = 1;
    }
    else
    {
       TTPLPFC_ac_sign_filtered = 0;
    }

}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_runCurrentLoop)
static inline void TTPLPFC_runCurrentLoop()
{
    if(TTPLPFC_closeGiLoop == 1)
    {

    #if TTPLPFC_SFRA_TYPE == TTPLPFC_SFRA_CURRENT
        TTPLPFC_gi1_out = TTPLPFC_GI_RUN(&TTPLPFC_gi1, TTPLPFC_iL1_sensed_pu,
                            SFRA_F32_inject(TTPLPFC_ac_cur_ref_inst_pu));

    #else
        TTPLPFC_gi1_out = TTPLPFC_GI_RUN(&TTPLPFC_gi1, TTPLPFC_iL1_sensed_pu,
                                        TTPLPFC_ac_cur_ref_inst_pu);
    #endif

        TTPLPFC_gi2_out = TTPLPFC_GI_RUN(&TTPLPFC_gi2, TTPLPFC_iL2_sensed_pu,
                                                TTPLPFC_ac_cur_ref_inst_pu);

//        TTPLPFC_duty1_pu = TTPLPFC_gi1_out;
//        TTPLPFC_duty2_pu = TTPLPFC_gi2_out;

        TTPLPFC_duty1_pu = (TTPLPFC_gi1_out + TTPLPFC_gi1_out_ff_scale*((TTPLPFC_ac_vol_sensed_pu *
                    (float32_t)TTPLPFC_VAC_MAX_SENSE /
                    (float32_t)TTPLPFC_VBUS_TYPICAL)));//TTPLPFC_VDCBUS_MAX_SENSE)));// -
//                    TTPLPFC_inductor_voltage_drop_feedforward));
//                  /(TTPLPFC_vBus_sensed_pu);

        TTPLPFC_duty2_pu = (TTPLPFC_gi2_out + TTPLPFC_gi1_out_ff_scale*((TTPLPFC_ac_vol_sensed_pu *
                    (float32_t)TTPLPFC_VAC_MAX_SENSE /
                    (float32_t)TTPLPFC_VBUS_TYPICAL)));//TTPLPFC_VDCBUS_MAX_SENSE)));// -
//                    TTPLPFC_inductor_voltage_drop_feedforward));
//                  /(TTPLPFC_vBus_sensed_pu);

        TTPLPFC_duty1_pu = (TTPLPFC_duty1_pu > (float32_t)(TTPLPFC_duty_clamp_high_pu))?
                (float32_t)(TTPLPFC_duty_clamp_high_pu):TTPLPFC_duty1_pu;
        TTPLPFC_duty1_pu = (TTPLPFC_duty1_pu < (float32_t)(TTPLPFC_duty_clamp_low_pu))?
                (float32_t)(TTPLPFC_duty_clamp_low_pu):TTPLPFC_duty1_pu;

        TTPLPFC_duty2_pu = (TTPLPFC_duty2_pu > (float32_t)(TTPLPFC_duty_clamp_high_pu))?
                (float32_t)(TTPLPFC_duty_clamp_high_pu):TTPLPFC_duty2_pu;
        TTPLPFC_duty2_pu = (TTPLPFC_duty2_pu < (float32_t)(TTPLPFC_duty_clamp_low_pu))?
                (float32_t)(TTPLPFC_duty_clamp_low_pu):TTPLPFC_duty2_pu;
    }
    else
    {
        TTPLPFC_duty1_pu = 0.01f;
        TTPLPFC_duty2_pu = 0.01f;
    }
}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_acCurrentRef)
static inline void TTPLPFC_acCurrentRef()
{
    if(TTPLPFC_closeGiLoop == 1)
    {
        #if  TTPLPFC_DC_CHECK == 1
                TTPLPFC_ac_cur_ref_inst_pu = TTPLPFC_ac_cur_ref_pu;
        #else
            #if TTPLPFC_INPUT_CAP_COMPENSATION == 1
                TTPLPFC_ac_cur_ref_inst_pu = TTPLPFC_ac_cur_ref_pu *
                        TTPLPFC_spll_sine + TTPLPFC_thetaOffset_pu *
                        TTPLPFC_spll_cosine;
            #else
                TTPLPFC_ac_cur_ref_inst_pu = TTPLPFC_ac_cur_ref_pu *
                        TTPLPFC_spll1.sine;
            #endif
        #endif
    }

        TTPLPFC_inductor_voltage_drop_feedforward = (float32_t)1.0*
         ((TTPLPFC_ac_cur_ref_inst_pu - TTPLPFC_ac_cur_ref_inst_prev_pu)/1.0f) *
               ((float32_t)TTPLPFC_INDUCTOR_VALUE*TTPLPFC_CONTROL_ISR_FREQUENCY*
                                TTPLPFC_IL_MAX_SENSE / TTPLPFC_VDCBUS_MAX_SENSE);


    TTPLPFC_ac_cur_ref_inst_prev_pu = TTPLPFC_ac_cur_ref_inst_pu;
}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_runVoltageLoop)
static inline void TTPLPFC_runVoltageLoop()
{
    //
    // Soft start for the voltage set point
    //
    if(TTPLPFC_closeGvLoop == 1)
    {
        if( fabsf(TTPLPFC_vBusRef_pu - TTPLPFC_vBusRefSlewed_pu) > 0.0001f)
        {
            if(TTPLPFC_vBusRef_pu > TTPLPFC_vBusRefSlewed_pu)
            {
                TTPLPFC_vBusRefSlewed_pu = TTPLPFC_vBusRefSlewed_pu + 0.0001f;
            }
            else
            {
                TTPLPFC_vBusRefSlewed_pu = TTPLPFC_vBusRefSlewed_pu - 0.0001f;
            }
        }
        else
        {
            TTPLPFC_vBusRefSlewed_pu = TTPLPFC_vBusRef_pu;
        }

        #if TTPLPFC_NON_LINEAR_VOLTAGE_LOOP == 1
            TTPLPFC_nonLinearVoltageLoopFlag = 1;
        #else
            TTPLPFC_nonLinearVoltageLoopFlag = 0;
        #endif

    }

    if(TTPLPFC_closeGvLoop == 1)
    {
        if(TTPLPFC_firstTimeGvLoop == 1)
        {
            TTPLPFC_vBusRefSlewed_pu = TTPLPFC_vBus_sensed_pu;
            TTPLPFC_firstTimeGvLoop = 0;
        }

        TTPLPFC_voltage_error = fabsf(TTPLPFC_vBusRefSlewed_pu -
                                      TTPLPFC_vBus_sensedFiltered_notch2);

        if(TTPLPFC_nonLinearVoltageLoopFlag == 0)
        {
            TTPLPFC_gv.Kp = TTPLPFC_GV_PI_KP;
            TTPLPFC_gv.Ki = TTPLPFC_GV_PI_KI;
        }
        else
        {
            if(TTPLPFC_voltage_error > 0.005f)
            {
                if(TTPLPFC_gv.Kp < (TTPLPFC_NON_LINEAR_V_LOOP_KP_MULTIPLIER *
                        TTPLPFC_GV_PI_KP))
                {
                    TTPLPFC_gv.Kp = TTPLPFC_gv.Kp + 0.05f;
                }
            }
            else if(TTPLPFC_voltage_error < 0.001f)
            {
                if(TTPLPFC_gv.Kp > TTPLPFC_GV_PI_KP)
                {
                    TTPLPFC_gv.Kp = TTPLPFC_gv.Kp - 0.05f;
                }
            }
        }


        #if TTPLPFC_SFRA_TYPE == TTPLPFC_SFRA_VOLTAGE
        TTPLPFC_gv_out = TTPLPFC_GV_RUN(&TTPLPFC_gv,
                                      SFRA_F32_inject(TTPLPFC_vBusRefSlewed_pu),
                                      TTPLPFC_vBus_sensedFiltered_notch2);
        #else
        TTPLPFC_gv_out = TTPLPFC_GV_RUN(&TTPLPFC_gv,
                                      TTPLPFC_vBusRefSlewed_pu,
                                      TTPLPFC_vBus_sensedFiltered_notch2);
        #endif

        #if TTPLPFC_SFRA_TYPE == TTPLPFC_SFRA_VOLTAGE
            SFRA_F32_collect((float32_t*)&TTPLPFC_gv_out,
                             (float32_t*)&TTPLPFC_vBus_sensedFiltered_notch2);
        #endif

            TTPLPFC_ac_cur_ref_pu = TTPLPFC_gv_out / TTPLPFC_vRmsAvg_pu;
                                    // * TTPLPFC_vBusAvg_pu /

    }
}

//#define TTPLPFC_SS_SCALE 150//30 increase counter to 20
#pragma FUNC_ALWAYS_INLINE(TTPLPFC_pwmDriver)
static inline void TTPLPFC_pwmDriver()
{
    switch(TTPLPFC_pwm_SwState.enum_pwmSwState)
    {
        case pwmSwState_normalOperation:

            //
            // wait for positive zero crossing
            //
            if(TTPLPFC_acSine < TTPLPFC_threshold_PZC2  &&
                    TTPLPFC_acSinePrev < 0)
            {
                TTPLPFC_pwm_SwState.enum_pwmSwState =
                        pwmSwState_positiveZeroCrossing1;

                TTPLPFC_duty1_pu = 0.004;
                TTPLPFC_duty2_pu = 0.004;

                TTPLPFC_HAL_AQ_SW_FORCE_PWMxA_LOW_PWMxB_LOW(
                        TTPLPFC_LOW_FREQ_PWM_BASE);

                TTPLPFC_HAL_SET_PWM_DBRED(
                        TTPLPFC_HIGH_FREQ_PWM1_BASE, TTPLPFC_PWM_PERIOD);
                TTPLPFC_HAL_SET_PWM_DBFED(
                        TTPLPFC_HIGH_FREQ_PWM1_BASE, TTPLPFC_PWM_PERIOD);

                TTPLPFC_HAL_SET_PWM_DBRED(
                        TTPLPFC_HIGH_FREQ_PWM2_BASE, TTPLPFC_PWM_PERIOD);
                TTPLPFC_HAL_SET_PWM_DBFED(
                        TTPLPFC_HIGH_FREQ_PWM2_BASE, TTPLPFC_PWM_PERIOD);

                TTPLPFC_gi1.i10 = 0;
                TTPLPFC_gi1.i6 = 1;
                TTPLPFC_gi1_out = 0;

                TTPLPFC_gi2.i10 = 0;
                TTPLPFC_gi2.i6 = 1;
                TTPLPFC_gi2_out = 0;

                TTPLPFC_HAL_clearPWMTripFlags(TTPLPFC_LOW_FREQ_PWM_BASE);
                TTPLPFC_HAL_clearPWMTripFlags(TTPLPFC_HIGH_FREQ_PWM1_BASE);
                TTPLPFC_HAL_clearPWMTripFlags(TTPLPFC_HIGH_FREQ_PWM2_BASE);

                TTPLPFC_ac_cur_ref_inst_pu = 0.00f;
                TTPLPFC_ac_cur_ref_inst_prev_pu = 0.00f;
                TTPLPFC_closeGiLoop = 1;
                TTPLPFC_closeGvLoop = 1;
            }
            #if TTPLPFC_AEF_ENABLED == 1
                AEF_enable = 0;
                AEF_closeLoop = 0;
            #endif

            break;

        case pwmSwState_positiveHalf:

            //
            //AQCSFRC xA LOW, xB HIGH
            //
            TTPLPFC_HAL_AQ_SW_FORCE_PWMxA_LOW_PWMxB_HIGH(
                    TTPLPFC_LOW_FREQ_PWM_BASE);

            TTPLPFC_HAL_SET_PWM_DBRED(
                 TTPLPFC_HIGH_FREQ_PWM1_BASE, TTPLPFC_dbRED_SetValue_ticks);

            TTPLPFC_HAL_SET_PWM_DBRED(
                 TTPLPFC_HIGH_FREQ_PWM2_BASE, TTPLPFC_dbRED_SetValue_ticks);

            #if TTPLPFC_AEF_ENABLED == 1
                if(TTPLPFC_acSine < -AEF_emi_inj_threshold_pu ||
                        TTPLPFC_acSine > AEF_emi_inj_threshold_pu/2)
                {
                   AEF_enable = 1;
                   AEF_closeLoop = 1;
                }
                else
                {
                   AEF_enable = 0;
                   AEF_closeLoop = 0;
                }
            #endif

            if( TTPLPFC_acSine < TTPLPFC_threshold_NZC1
                    || TTPLPFC_ac_sign_filtered == 0 )
            {
                TTPLPFC_pwm_SwState.enum_pwmSwState =
                        pwmSwState_negativeZeroCrossing1;

                //
                //AQCSFRC xA LOW, xB LOW
                //
                TTPLPFC_HAL_AQ_SW_FORCE_PWMxA_LOW_PWMxB_LOW(
                        TTPLPFC_LOW_FREQ_PWM_BASE);

                #if TTPLPFC_AEF_ENABLED == 1
                AEF_enable = 0;
                AEF_closeLoop = 0;
                #endif
            }


            break;

        case pwmSwState_negativeZeroCrossing1 :
            //
            // Now write a large value to the deadband registers RED and FED
            // to eliminate any pulse on xA and xB channel
            //
            TTPLPFC_HAL_SET_PWM_DBRED(
                    TTPLPFC_HIGH_FREQ_PWM1_BASE, TTPLPFC_PWM_PERIOD);
            TTPLPFC_HAL_SET_PWM_DBFED(
                    TTPLPFC_HIGH_FREQ_PWM1_BASE, TTPLPFC_PWM_PERIOD);

            TTPLPFC_HAL_SET_PWM_DBRED(
                    TTPLPFC_HIGH_FREQ_PWM2_BASE, TTPLPFC_PWM_PERIOD);
            TTPLPFC_HAL_SET_PWM_DBFED(
                    TTPLPFC_HIGH_FREQ_PWM2_BASE, TTPLPFC_PWM_PERIOD);

            //
            // clamp the duty to TTPLPFC_DUTY_MIN to ensure there is a rising edge
            // and falling edge , otherwise a always high pulse can result
            // for one or more PWM cycles
            //
            TTPLPFC_duty1_pu = TTPLPFC_DUTY_MIN;
            TTPLPFC_duty2_pu = TTPLPFC_DUTY_MIN;

            #if TTPLPFC_AEF_ENABLED == 1
                AEF_enable = 0;
                AEF_closeLoop = 0;
            #endif
            //
            // now wait till actual zero in this state
            // before switching to zero2
            //
            if(TTPLPFC_acSine <= 0 )
            {
                TTPLPFC_pwm_SwState.enum_pwmSwState =
                        pwmSwState_negativeZeroCrossing2;
            }
            break;

        case pwmSwState_negativeZeroCrossing2 :

            TTPLPFC_duty1_pu = TTPLPFC_DUTY_MIN;
            TTPLPFC_duty2_pu = TTPLPFC_DUTY_MIN;

            #if TTPLPFC_AEF_ENABLED == 1
            AEF_enable = 0;
            AEF_closeLoop = 0;
            #endif

            if(TTPLPFC_acSine < TTPLPFC_threshold_NZC2)
            {
                TTPLPFC_state_slew = 0;
                TTPLPFC_softstart_duty = 0;
                TTPLPFC_pwm_SwState.enum_pwmSwState =
                        pwmSwState_negativeZeroCrossing3;

                //
                // Enable xA xB Swap
                //
                TTPLPFC_HAL_ENABLE_SWAP_DEADBAND_OUTPUT(
                        TTPLPFC_HIGH_FREQ_PWM1_BASE);
                TTPLPFC_HAL_ENABLE_SWAP_DEADBAND_OUTPUT(
                        TTPLPFC_HIGH_FREQ_PWM2_BASE);

#if TTPLPFC_PWM_AC_SR_OFF == 1
                TTPLPFC_HAL_disableLowSideHFPWM();
                TTPLPFC_HAL_enableHighSideHFPWM();
#endif

                TTPLPFC_gi1.i10 = 0;
                TTPLPFC_gi1.i6 = 1;
                TTPLPFC_gi1.Ki = 0;
                TTPLPFC_gi1_out = 0;

                TTPLPFC_gi2.i10 = 0;
                TTPLPFC_gi2.i6 = 1;
                TTPLPFC_gi2.Ki = 0;
                TTPLPFC_gi2_out = 0;
            }

            break;

        case pwmSwState_negativeZeroCrossing3 :
            TTPLPFC_state_slew++;

            TTPLPFC_duty1_pu = TTPLPFC_DUTY_MIN;
            TTPLPFC_duty2_pu = TTPLPFC_DUTY_MIN;

            TTPLPFC_softstart_duty = TTPLPFC_softstart_duty + 1;

            //
            // The below is modified vs originial TIDM-1007 to accomodate CM on LISN
            //
            TTPLPFC_softStartDeadBandFED = ( (float32_t) TTPLPFC_PWM_PERIOD  -
                                TTPLPFC_softstart_duty * TTPLPFC_softStartDeadbandScalingFactor );

            if(TTPLPFC_softStartDeadBandFED < TTPLPFC_dbFED_SetValue_ticks )
            {
                TTPLPFC_softStartDeadBandFED = TTPLPFC_dbFED_SetValue_ticks;
            }

            TTPLPFC_HAL_SET_PWM_DBFED(TTPLPFC_HIGH_FREQ_PWM1_BASE,
                                     TTPLPFC_softStartDeadBandFED );

            TTPLPFC_HAL_SET_PWM_DBFED(TTPLPFC_HIGH_FREQ_PWM2_BASE,
                                     TTPLPFC_softStartDeadBandFED );

            #if TTPLPFC_AEF_ENABLED == 1
            AEF_enable = 0;
            AEF_closeLoop = 0;
            #endif

            if(TTPLPFC_state_slew > TTPLPFC_state_slew_max
                    && TTPLPFC_ac_sign_filtered == 0 )
            {
                TTPLPFC_gi1.i10 = 0;
                TTPLPFC_gi1.i6 = 1;
                TTPLPFC_gi1.Ki = TTPLPFC_gi_Ki;
                TTPLPFC_gi1.Kp = TTPLPFC_gi_Kp;
                TTPLPFC_gi1_out = 0;
                TTPLPFC_gi1.Umax = TTPLPFC_GI_PI_MAX;
                TTPLPFC_gi1.Umin = TTPLPFC_GI_PI_MIN;

                TTPLPFC_gi2.i10 = 0;
                TTPLPFC_gi2.i6 = 1;
                TTPLPFC_gi2.Ki = TTPLPFC_gi_Ki;
                TTPLPFC_gi2.Kp = TTPLPFC_gi_Kp;
                TTPLPFC_gi2_out = 0;
                TTPLPFC_gi2.Umax = TTPLPFC_GI_PI_MAX;
                TTPLPFC_gi2.Umin = TTPLPFC_GI_PI_MIN;

                TTPLPFC_duty_clamp_high_pu = 0.0f;
                TTPLPFC_duty_clamp_low_pu = -1.0f;

                TTPLPFC_pwm_SwState.enum_pwmSwState
                                         = pwmSwState_negativeHalf;

                TTPLPFC_HAL_SET_PWM_DBFED(TTPLPFC_HIGH_FREQ_PWM1_BASE,
                                          TTPLPFC_dbFED_SetValue_ticks);
                TTPLPFC_HAL_SET_PWM_DBFED(TTPLPFC_HIGH_FREQ_PWM2_BASE,
                                          TTPLPFC_dbFED_SetValue_ticks);

                TTPLPFC_state_slew = 0;
            }
            break;

        case pwmSwState_negativeHalf:

            //
            //AQCSFRC xA HIGH, xB LOW
            //
            TTPLPFC_HAL_AQ_SW_FORCE_PWMxA_HIGH_PWMxB_LOW(
                    TTPLPFC_LOW_FREQ_PWM_BASE);

            TTPLPFC_HAL_SET_PWM_DBRED(TTPLPFC_HIGH_FREQ_PWM1_BASE,
                                      TTPLPFC_dbRED_SetValue1_ticks);

            TTPLPFC_HAL_SET_PWM_DBRED(TTPLPFC_HIGH_FREQ_PWM2_BASE,
                                      TTPLPFC_dbRED_SetValue2_ticks);


            #if TTPLPFC_AEF_ENABLED == 1
                if(TTPLPFC_acSine < -AEF_emi_inj_threshold_pu ||
                                TTPLPFC_acSine > AEF_emi_inj_threshold_pu/2)
                {
                   AEF_enable = 1;
                   AEF_closeLoop = 1;
                }
                else
                {
                   AEF_enable = 0;
                   AEF_closeLoop = 0;
                }
            #endif


            if( TTPLPFC_acSine > TTPLPFC_threshold_PZC1 ||
                    TTPLPFC_ac_sign_filtered == 1)
            {
                TTPLPFC_pwm_SwState.enum_pwmSwState =
                        pwmSwState_positiveZeroCrossing1;

                //
                // AQCSFRC xA LOW, xB LOW  for the low freq switches
                //
                TTPLPFC_HAL_AQ_SW_FORCE_PWMxA_LOW_PWMxB_LOW(
                        TTPLPFC_LOW_FREQ_PWM_BASE);

                #if TTPLPFC_AEF_ENABLED == 1
                    AEF_enable = 0;
                    AEF_closeLoop = 0;
                #endif

            }
            break;

        case pwmSwState_positiveZeroCrossing1 :

            //
            // Now write a large value to the deadband registers RED and FED
            // to eliminate any pulse on xA and xB channel
            //
            TTPLPFC_HAL_SET_PWM_DBRED(TTPLPFC_HIGH_FREQ_PWM1_BASE,
                                      TTPLPFC_PWM_PERIOD);
            TTPLPFC_HAL_SET_PWM_DBFED(TTPLPFC_HIGH_FREQ_PWM1_BASE,
                                      TTPLPFC_PWM_PERIOD);

            TTPLPFC_HAL_SET_PWM_DBRED(TTPLPFC_HIGH_FREQ_PWM2_BASE,
                                      TTPLPFC_PWM_PERIOD);
            TTPLPFC_HAL_SET_PWM_DBFED(TTPLPFC_HIGH_FREQ_PWM2_BASE,
                                      TTPLPFC_PWM_PERIOD);

            //
            // clamp the duty to TTPLPFC_DUTY_MIN to ensure there is a rising edge
            // and falling edge , otherwise a always high pulse can result
            // for one or more PWM cycles
            //
            TTPLPFC_duty1_pu = TTPLPFC_DUTY_MIN;
            TTPLPFC_duty2_pu = TTPLPFC_DUTY_MIN;

            #if TTPLPFC_AEF_ENABLED == 1
                AEF_enable = 0;
                AEF_closeLoop = 0;
            #endif

            if(TTPLPFC_acSine >= 0 )
            {
                TTPLPFC_pwm_SwState.enum_pwmSwState =
                        pwmSwState_positiveZeroCrossing2;
            }
            break;

        case pwmSwState_positiveZeroCrossing2 :

            TTPLPFC_duty1_pu = TTPLPFC_DUTY_MIN;
            TTPLPFC_duty2_pu = TTPLPFC_DUTY_MIN;

            #if TTPLPFC_AEF_ENABLED == 1
            AEF_enable = 0;
            AEF_closeLoop = 0;
            #endif

            if(TTPLPFC_acSine > TTPLPFC_threshold_PZC2 )
            {
                TTPLPFC_state_slew = 0;
                TTPLPFC_softstart_duty = 0;
                TTPLPFC_pwm_SwState.enum_pwmSwState =
                        pwmSwState_positiveZeroCrossing3;

                //
                // Dead band output swap disabled
                //
                TTPLPFC_HAL_DISABLE_SWAP_DEADBAND_OUTPUT(
                        TTPLPFC_HIGH_FREQ_PWM1_BASE);

                TTPLPFC_HAL_DISABLE_SWAP_DEADBAND_OUTPUT(
                        TTPLPFC_HIGH_FREQ_PWM2_BASE);

#if TTPLPFC_PWM_AC_SR_OFF == 1
                TTPLPFC_HAL_disableHighSideHFPWM();
                TTPLPFC_HAL_enableLowSideHFPWM();

#endif

                TTPLPFC_gi1.i10 = 0;
                TTPLPFC_gi1.i6 = 1;
                TTPLPFC_gi1_out = 0;
                TTPLPFC_gi1.Ki = 0;

                TTPLPFC_gi2.i10 = 0;
                TTPLPFC_gi2.i6 = 1;
                TTPLPFC_gi2_out = 0;
                TTPLPFC_gi2.Ki = 0;
            }
            break;

        case pwmSwState_positiveZeroCrossing3 :
            TTPLPFC_state_slew++;
            TTPLPFC_duty1_pu = TTPLPFC_DUTY_MIN;
            TTPLPFC_duty2_pu = TTPLPFC_DUTY_MIN;

            TTPLPFC_softstart_duty = TTPLPFC_softstart_duty + 1;

            TTPLPFC_softStartDeadBandFED = ( (float32_t) TTPLPFC_PWM_PERIOD  -
                    TTPLPFC_softstart_duty * TTPLPFC_softStartDeadbandScalingFactor );

            if(TTPLPFC_softStartDeadBandFED < TTPLPFC_dbFED_SetValue_ticks )
            {
                TTPLPFC_softStartDeadBandFED = TTPLPFC_dbFED_SetValue_ticks;
            }

            TTPLPFC_HAL_SET_PWM_DBFED(TTPLPFC_HIGH_FREQ_PWM1_BASE,
                                      TTPLPFC_softStartDeadBandFED );

            TTPLPFC_HAL_SET_PWM_DBFED(TTPLPFC_HIGH_FREQ_PWM2_BASE,
                                      TTPLPFC_softStartDeadBandFED );

            #if TTPLPFC_AEF_ENABLED == 1
            AEF_enable = 0;
            AEF_closeLoop = 0;
            #endif

            if(TTPLPFC_state_slew > TTPLPFC_state_slew_max &&
                    TTPLPFC_ac_sign_filtered == 1)
            {
                TTPLPFC_gi1.i10 = 0;
                TTPLPFC_gi1.i6 = 1;
                TTPLPFC_gi1_out = 0;
                TTPLPFC_gi1.Ki = TTPLPFC_gi_Ki;
                TTPLPFC_gi1.Kp = TTPLPFC_gi_Kp;
                TTPLPFC_gi1.Umax = TTPLPFC_GI_PI_MAX;
                TTPLPFC_gi1.Umin = TTPLPFC_GI_PI_MIN;

                TTPLPFC_gi2.i10 = 0;
                TTPLPFC_gi2.i6 = 1;
                TTPLPFC_gi2_out = 0;
                TTPLPFC_gi2.Ki = TTPLPFC_gi_Ki;
                TTPLPFC_gi2.Kp = TTPLPFC_gi_Kp;
                TTPLPFC_gi2.Umax = TTPLPFC_GI_PI_MAX;
                TTPLPFC_gi2.Umin = TTPLPFC_GI_PI_MIN;

                TTPLPFC_duty_clamp_high_pu = 1.0f;
                TTPLPFC_duty_clamp_low_pu = 0.0f;

                TTPLPFC_pwm_SwState.enum_pwmSwState =
                        pwmSwState_positiveHalf;

                TTPLPFC_HAL_SET_PWM_DBFED(TTPLPFC_HIGH_FREQ_PWM1_BASE,
                                          TTPLPFC_dbFED_SetValue_ticks);

                TTPLPFC_HAL_SET_PWM_DBFED(TTPLPFC_HIGH_FREQ_PWM2_BASE,
                                          TTPLPFC_dbFED_SetValue_ticks);

                TTPLPFC_state_slew = 0;
            }

            break;

        case pwmSwState_defaultState:
            TTPLPFC_duty1_pu = 0.01f;
            TTPLPFC_duty2_pu = 0.01f;

            TTPLPFC_HAL_AQ_SW_FORCE_PWMxA_LOW_PWMxB_LOW(
                    TTPLPFC_LOW_FREQ_PWM_BASE);

            TTPLPFC_HAL_SET_PWM_DBRED(TTPLPFC_HIGH_FREQ_PWM1_BASE,
                                      TTPLPFC_PWM_PERIOD);
            TTPLPFC_HAL_SET_PWM_DBFED(TTPLPFC_HIGH_FREQ_PWM1_BASE,
                                      TTPLPFC_PWM_PERIOD);

            TTPLPFC_HAL_SET_PWM_DBRED(TTPLPFC_HIGH_FREQ_PWM2_BASE,
                                      TTPLPFC_PWM_PERIOD);
            TTPLPFC_HAL_SET_PWM_DBFED(TTPLPFC_HIGH_FREQ_PWM2_BASE,
                                      TTPLPFC_PWM_PERIOD);

            #if TTPLPFC_AEF_ENABLED == 1
            AEF_enable = 0;
            AEF_closeLoop = 0;
            #endif

            break;
        default:
            TTPLPFC_pwm_SwState.enum_pwmSwState =
                    pwmSwState_defaultState;
    }

    #if TTPLPFC_AEF_ENABLED == 1
    if(fabsf(TTPLPFC_dutyPU) < 0.1 || fabsf(TTPLPFC_dutyPU) > 0.95 )
    {
        AEF_enable = 0;
    }
    #endif
}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_pwmDriver_DC)
static inline void TTPLPFC_pwmDriver_DC()
{
    if(TTPLPFC_duty1_pu > 0.0f)
    {
        //
        //AQCSFRC xA LOW, xB HIGH
        //
        TTPLPFC_HAL_AQ_SW_FORCE_PWMxA_LOW_PWMxB_HIGH(
                TTPLPFC_LOW_FREQ_PWM_BASE);

        TTPLPFC_HAL_SET_PWM_DBRED(TTPLPFC_HIGH_FREQ_PWM1_BASE,
                                  TTPLPFC_dbRED_SetValue_ticks);
        TTPLPFC_HAL_SET_PWM_DBFED(TTPLPFC_HIGH_FREQ_PWM1_BASE,
                                  TTPLPFC_dbFED_SetValue_ticks);
        TTPLPFC_HAL_DISABLE_SWAP_DEADBAND_OUTPUT(
                            TTPLPFC_HIGH_FREQ_PWM1_BASE);

        TTPLPFC_HAL_SET_PWM_DBRED(TTPLPFC_HIGH_FREQ_PWM2_BASE,
                                  TTPLPFC_dbRED_SetValue_ticks);
        TTPLPFC_HAL_SET_PWM_DBFED(TTPLPFC_HIGH_FREQ_PWM2_BASE,
                                  TTPLPFC_dbFED_SetValue_ticks);
        TTPLPFC_HAL_DISABLE_SWAP_DEADBAND_OUTPUT(
                            TTPLPFC_HIGH_FREQ_PWM2_BASE);

    }
    else if(TTPLPFC_duty1_pu < 0)
    {
        //
        //AQCSFRC xA HIGH, xB LOW
        //
        TTPLPFC_HAL_AQ_SW_FORCE_PWMxA_HIGH_PWMxB_LOW(
                TTPLPFC_LOW_FREQ_PWM_BASE);

        TTPLPFC_HAL_SET_PWM_DBRED(TTPLPFC_HIGH_FREQ_PWM1_BASE,
                                  TTPLPFC_dbRED_SetValue_ticks);
        TTPLPFC_HAL_SET_PWM_DBFED(TTPLPFC_HIGH_FREQ_PWM1_BASE,
                                  TTPLPFC_dbFED_SetValue_ticks);
        TTPLPFC_HAL_ENABLE_SWAP_DEADBAND_OUTPUT(
                            TTPLPFC_HIGH_FREQ_PWM1_BASE);

        TTPLPFC_HAL_SET_PWM_DBRED(TTPLPFC_HIGH_FREQ_PWM2_BASE,
                                  TTPLPFC_dbRED_SetValue_ticks);
        TTPLPFC_HAL_SET_PWM_DBFED(TTPLPFC_HIGH_FREQ_PWM2_BASE,
                                  TTPLPFC_dbFED_SetValue_ticks);
        TTPLPFC_HAL_ENABLE_SWAP_DEADBAND_OUTPUT(
                            TTPLPFC_HIGH_FREQ_PWM2_BASE);

    }
}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_adaptiveDeadTime)
static inline void TTPLPFC_adaptiveDeadTime()
{
    #if TTPLPFC_ADAPTIVE_DEADTIME == 1
        TTPLPFC_ac_cur_sensed_Amps = fabsf(TTPLPFC_ac_cur_sensed_pu *
                                         TTPLPFC_I_MAX_SENSE);
        TTPLPFC_ac_cur_sensed_Amps = (TTPLPFC_ac_cur_sensed_Amps < 0.01f)?0.01f:
                TTPLPFC_ac_cur_sensed_Amps;

        TTPLPFC_dbRED_SetValue_Temp_ticks = (uint16_t)((float32_t)100000000.0 *
                            (2.0 * TTPLPFC_VBUS_TYPICAL * TTPLPFC_HF_FET_COSS) /
                            (TTPLPFC_ac_cur_sensed_Amps*0.33));

        TTPLPFC_dbRED_SetValue_ticks = (TTPLPFC_dbRED_SetValue_Temp_ticks <
                TTPLPFC_dbRED_Min_ticks)?TTPLPFC_dbRED_Min_ticks:
                                        TTPLPFC_dbRED_SetValue_Temp_ticks;
        TTPLPFC_dbRED_SetValue_ticks = (TTPLPFC_dbRED_SetValue_Temp_ticks >
                TTPLPFC_dbRED_Max_ticks)?TTPLPFC_dbRED_Max_ticks:
                                        TTPLPFC_dbRED_SetValue_Temp_ticks;

        //
        // Individual Peak Current Sensing
        //

//        //
//        // Phase A
//        //
//        TTPLPFC_iL1_sensed_Amps = fabsf(TTPLPFC_iL1_sensed_pu *
//                                      TTPLPFC_I_INDIVIDUAL_MAX_SENSE);
//        TTPLPFC_iL1_sensed_Amps = (TTPLPFC_iL1_sensed_Amps < 0.0033f)?
//                0.0033f:TTPLPFC_iL1_sensed_Amps;
//
//        TTPLPFC_dbRED_SetValue_Temp1_ticks = (uint16_t)((float32_t)100000000.0 *
//                            (2.0 * TTPLPFC_VBUS_TYPICAL * TTPLPFC_HF_FET_COSS) /
//                            (TTPLPFC_iL1_sensed_Amps));
//        TTPLPFC_dbRED_SetValue1_ticks = (TTPLPFC_dbRED_SetValue_Temp1_ticks <
//                TTPLPFC_dbRED_Min_ticks)?TTPLPFC_dbRED_Min_ticks:
//                                         TTPLPFC_dbRED_SetValue_Temp1_ticks;
//        TTPLPFC_dbRED_SetValue1_ticks = (TTPLPFC_dbRED_SetValue_Temp1_ticks >
//        TTPLPFC_dbRED_Max_ticks)?TTPLPFC_dbRED_Max_ticks:
//                                         TTPLPFC_dbRED_SetValue_Temp1_ticks;
//
//        //
//        // Phase B
//        //
//        TTPLPFC_iL2_sensed_Amps = fabsf(TTPLPFC_iL2_sensed_pu *
//                                      TTPLPFC_I_INDIVIDUAL_MAX_SENSE);
//        TTPLPFC_iL2_sensed_Amps = (TTPLPFC_iL2_sensed_Amps < 0.0033f)?
//                0.0033f:TTPLPFC_iL2_sensed_Amps;
//
//        TTPLPFC_dbRED_SetValue_Temp2_ticks = (uint16_t)((float32_t)100000000.0 *
//                            (2.0 * TTPLPFC_VBUS_TYPICAL * TTPLPFC_HF_FET_COSS) /
//                            (TTPLPFC_iL2_sensed_Amps)
//                                 );
//        TTPLPFC_dbRED_SetValue2_ticks = (TTPLPFC_dbRED_SetValue_Temp2_ticks <
//                TTPLPFC_dbRED_Min_ticks)?TTPLPFC_dbRED_Min_ticks:
//                                         TTPLPFC_dbRED_SetValue_Temp2_ticks;
//        TTPLPFC_dbRED_SetValue2_ticks = (TTPLPFC_dbRED_SetValue_Temp2_ticks >
//        TTPLPFC_dbRED_Max_ticks)?TTPLPFC_dbRED_Max_ticks:
//                                         TTPLPFC_dbRED_SetValue_Temp2_ticks;
//
//        //
//        // Phase C
//        //
//        TTPLPFC_iL3_sensed_Amps = fabsf(TTPLPFC_iL3_sensed_pu *
//                                      TTPLPFC_I_INDIVIDUAL_MAX_SENSE);
//        TTPLPFC_iL3_sensed_Amps = (TTPLPFC_iL3_sensed_Amps < 0.0033f)?
//                0.0033f:TTPLPFC_iL3_sensed_Amps;
//
//        TTPLPFC_dbRED_SetValue_Temp3_ticks = (uint16_t)((float32_t)100000000.0 *
//                            (2.0 * TTPLPFC_VBUS_TYPICAL * TTPLPFC_HF_FET_COSS) /
//                            (TTPLPFC_iL3_sensed_Amps));
//        TTPLPFC_dbRED_SetValue3_ticks = (TTPLPFC_dbRED_SetValue_Temp3_ticks <
//                TTPLPFC_dbRED_Min_ticks)?TTPLPFC_dbRED_Min_ticks:
//                                         TTPLPFC_dbRED_SetValue_Temp3_ticks;
//        TTPLPFC_dbRED_SetValue3_ticks = (TTPLPFC_dbRED_SetValue_Temp3_ticks >
//        TTPLPFC_dbRED_Max_ticks)?TTPLPFC_dbRED_Max_ticks:
//                                         TTPLPFC_dbRED_SetValue_Temp3_ticks;

    #else
        TTPLPFC_dbRED_SetValue_ticks =
                TTPLPFC_HIGH_FREQ_PWM_DEADBAND_RED_COUNT;
        TTPLPFC_dbRED_SetValue1_ticks =
                TTPLPFC_HIGH_FREQ_PWM_DEADBAND_RED_COUNT;
        TTPLPFC_dbRED_SetValue2_ticks =
                TTPLPFC_HIGH_FREQ_PWM_DEADBAND_RED_COUNT;

    #endif
}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_SPLL)
static inline void TTPLPFC_SPLL()
{
    #if TTPLPFC_LAB == 5 || TTPLPFC_LAB == 6 || TTPLPFC_LAB == 7 ||            \
        TTPLPFC_LAB == 8 || (TTPLPFC_LAB == 1 && TTPLPFC_PWM_AC_CHECK == 1 )

        //
        //acSine is generated from ramp_gen for resistive load test
        //
        if(TTPLPFC_acSine > 0.0)
        {
            TTPLPFC_ac_sign_filtered = 1;
        }
        else
        {
            TTPLPFC_ac_sign_filtered = 0;
        }

            TTPLPFC_spll_sine = TTPLPFC_acSine;
            TTPLPFC_spll_cosine = TTPLPFC_acCosine;
    #else

        //
        //acSine is obtained from SPLL for grid-connected test
        //
        #if TTPLPFC_SPLL_METHOD_SELECT == TTPLPFC_SPLL_1PH_SOGI_SEL
            SPLL_1PH_SOGI_run(&TTPLPFC_spll1, TTPLPFC_ac_vol_sensed_pu);
            TTPLPFC_spll_sine = TTPLPFC_spll1.sine;
            TTPLPFC_spll_cosine = TTPLPFC_spll1.cosine;
            if(fabsf(TTPLPFC_spll1.ylf[0]) > 2.0f)
            {
                if(TTPLPFC_ac_vol_sensed_pu > 0.0)
                {
                    TTPLPFC_ac_sign_filtered = 1;
                }
                else
                {
                    TTPLPFC_ac_sign_filtered = 0;
                }
            }
            else
            {
                if(TTPLPFC_spll1.sine > 0.0)
                {
                    TTPLPFC_ac_sign_filtered = 1;
                }
                else
                {
                    TTPLPFC_ac_sign_filtered = 0;
                }
            }

            TTPLPFC_acSinePrev = TTPLPFC_acSine;
            TTPLPFC_acSine = TTPLPFC_spll_sine;
        #endif


        #if TTPLPFC_SPLL_METHOD_SELECT == TTPLPFC_TTPLPFC_SPLL_1PH_NOTCH_SEL
            SPLL_1PH_NOTCH_run(&TTPLPFC_spll2, TTPLPFC_ac_vol_sensed_pu);
            TTPLPFC_spll_sine = TTPLPFC_spll2.sine;
            TTPLPFC_spll_cosine = TTPLPFC_spll2.cosine;
            if(fabsf(TTPLPFC_spll2.ylf[0]) > 8.0f)
            {

                if(TTPLPFC_ac_vol_sensed_pu > 0.0)
                {
                    TTPLPFC_ac_sign_filtered = 1;
                }
                else
                {
                    TTPLPFC_ac_sign_filtered = 0;
                }
            }
            else
            {

                if(TTPLPFC_spll2.sine > 0.0)
                {
                    TTPLPFC_ac_sign_filtered = 1;
                }
                else
                {
                    TTPLPFC_ac_sign_filtered = 0;
                }
            }

            TTPLPFC_acSinePrev = TTPLPFC_acSine;
            TTPLPFC_acSine = TTPLPFC_spll_sine;
        #endif


        #if TTPLPFC_SPLL_METHOD_SELECT == TTPLPFC_SPLL_1PH_SOGI_FLL_SEL
          SPLL_1PH_SOGI_FLL_run(&TTPLPFC_spll3, TTPLPFC_ac_vol_sensed_pu);
          TTPLPFC_spll_sine = TTPLPFC_spll3.sine;
          TTPLPFC_spll_cosine = TTPLPFC_spll3.cosine;

            if(fabsf(TTPLPFC_spll3.ylf[0]) > 0.8f)
            {

                if(TTPLPFC_ac_vol_sensed_pu > 0.0)
                {
                    TTPLPFC_ac_sign_filtered = 1;
                }
                else
                {
                    TTPLPFC_ac_sign_filtered = 0;
                }
            }
            else
            {

                if(TTPLPFC_spll3.sine > 0.0)
                {
                    TTPLPFC_ac_sign_filtered = 1;
                }
                else
                {
                    TTPLPFC_ac_sign_filtered = 0;
                }
            }

            TTPLPFC_acSinePrev = TTPLPFC_acSine;
            TTPLPFC_acSine = TTPLPFC_spll_sine;
        #endif
    #endif



}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_dataLogger)
static inline void TTPLPFC_dataLogger()
{
    #ifndef __TMS320C28XX_CLA__

        #if(TTPLPFC_LAB == 1)
           //
           // check output voltage and inverter current meas.
           //
           TTPLPFC_dVal1 = TTPLPFC_ac_vol_sensed_pu;
           TTPLPFC_dVal2 = TTPLPFC_spll_sine;
           TTPLPFC_dVal3 = TTPLPFC_iL1_sensed_pu;
           TTPLPFC_dVal4 = TTPLPFC_iL2_sensed_pu;;
        #elif(TTPLPFC_LAB == 5 || TTPLPFC_LAB == 6)
            //
            // check output voltage and inverter current meas.
            //
            TTPLPFC_dVal1 = TTPLPFC_rgen.out;
            TTPLPFC_dVal2 = TTPLPFC_ac_vol_sensed_pu;
            TTPLPFC_dVal3 = TTPLPFC_acSine - TTPLPFC_spll3.sine;
            TTPLPFC_dVal4 = TTPLPFC_ac_cur_sensed_pu;
        #elif(TTPLPFC_LAB == 2 || TTPLPFC_LAB == 7 ||     \
              TTPLPFC_LAB == 8 || TTPLPFC_LAB == 9)
            //
            // check inverter current meas and reference.
            //
            TTPLPFC_dVal1 = TTPLPFC_spll1.sine;
            TTPLPFC_dVal2 = TTPLPFC_iL2_sensed_pu;;
            TTPLPFC_dVal3 = TTPLPFC_duty1_pu;
            TTPLPFC_dVal4 = TTPLPFC_ac_cur_sensed_pu;
        #elif(TTPLPFC_LAB == 3)
            TTPLPFC_dVal1 = TTPLPFC_ac_vol_sensed_pu;//TTPLPFC_closeGiLoop;
            TTPLPFC_dVal2 = TTPLPFC_spll_sine;//TTPLPFC_gi1_out;
            TTPLPFC_dVal3 = TTPLPFC_duty1_pu;
            TTPLPFC_dVal4 = TTPLPFC_ac_cur_sensed_pu;
        #else
            //
            // check inverter voltage meas and reference
            //
            TTPLPFC_dVal1 = TTPLPFC_acSine;
//            TTPLPFC_dVal2 = TTPLPFC_ac_cur_sensed_pu;
            TTPLPFC_dVal2 = TTPLPFC_ac_cur_sensed_pu;
//            TTPLPFC_dVal3 = TTPLPFC_vBusRefSlewed_pu - TTPLPFC_vBus_sensedFiltered_notch2;
//            TTPLPFC_dVal4 = TTPLPFC_gv_out;
//            TTPLPFC_dVal3 = TTPLPFC_iL1_sensed_pu;
//            TTPLPFC_dVal4 = TTPLPFC_iL2_sensed_pu;
            TTPLPFC_dVal3 = TTPLPFC_iL1_sensed_pu;
            TTPLPFC_dVal4 = TTPLPFC_iL2_sensed_pu;
//            TTPLPFC_dVal3 = TTPLPFC_ac_cur_ref_pu;
//            TTPLPFC_dVal4 = TTPLPFC_ac_cur_sensed_pu;
//            TTPLPFC_dVal4 = TTPLPFC_spll3.ylf[0];
        #endif
            DLOG_4CH_run(&TTPLPFC_dLog1);
    #endif
}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_rlyConnectFlag)
static inline void TTPLPFC_rlyConnectFlag()
{
    #if TTPLPFC_DC_CHECK == 0
        #if TTPLPFC_LAB <= 4
            //
            //Relay connection condition for PFC mode
            //
            if(TTPLPFC_ac_volRms_sensed_Volts > 75.0f ||
               TTPLPFC_vBus_sensed_Volts > 110.0f)
            {
                TTPLPFC_rlyConnect = 1;
            }
            else
            {
                TTPLPFC_rlyConnect = 0;
            }
        #else
            //
            //Relay connection condition for INV mode
            //
            if( TTPLPFC_vBus_sensed_Volts > TTPLPFC_vBus_underVoltage_Volts)
            {
                TTPLPFC_rlyConnect = 1;
            }
            else
            {
                TTPLPFC_rlyConnect = 0;
            }
        #endif
    #endif
}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_overVoltageProtection)
static inline void TTPLPFC_overVoltageProtection()
{
    #if TTPLPFC_LAB <= 4
        //
        // Overvoltage protection for PFC mode
        //
        if(TTPLPFC_vBus_sensed_Volts > TTPLPFC_vBus_overVoltage_Volts)
        {
            TTPLPFC_pwm_SwState.enum_pwmSwState = pwmSwState_defaultState;
            TTPLPFC_HAL_forceOSTPWMTrip_onAllPWM();
            if(TTPLPFC_board_Status.enum_boardStatus == boardStatus_NoFault)
            {
                TTPLPFC_ac_volRmsEma_sensed_Volts = 0;
            }
            TTPLPFC_board_Status.enum_boardStatus = boardStatus_OverVoltageTrip;
        }
    #else
        //
        // Overvoltage protection for INV mode
        //
        if(TTPLPFC_ac_volRms_sensed_Volts > TTPLPFC_ac_volRms_overVoltage_Volts)
        {
            TTPLPFC_pwm_SwState.enum_pwmSwState = pwmSwState_defaultState;
            TTPLPFC_HAL_forceOSTPWMTrip_onAllPWM();

            if(TTPLPFC_board_Status.enum_boardStatus == boardStatus_NoFault)
            {
                TTPLPFC_ac_volRmsEma_sensed_Volts = 0;
            }
            TTPLPFC_board_Status.enum_boardStatus = boardStatus_OverVoltageTrip;
        }
    #endif
}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_underVoltageProtection)
static inline void TTPLPFC_underVoltageProtection()
{
    #if(TTPLPFC_DC_CHECK == 0)
        #if(TTPLPFC_LAB <= 4)
        //
        //Undervoltage protection for PFC
        //
            if(TTPLPFC_ac_volRms_sensed_Volts < 75.0f)
                {
                    TTPLPFC_pwm_SwState.enum_pwmSwState =
                            pwmSwState_defaultState;
                    TTPLPFC_HAL_forceOSTPWMTrip_onAllPWM();

                    if(TTPLPFC_board_Status.enum_boardStatus
                            == boardStatus_NoFault)
                    {
                        TTPLPFC_ac_volRmsEma_sensed_Volts = 0;
                    }
                    TTPLPFC_board_Status.enum_boardStatus =
                            boardStatus_InputUnderVoltageTrip;
                }

        #else
            //
            //Undervoltage protection for INV
            //
            if(TTPLPFC_vBus_sensed_Volts < TTPLPFC_vBus_underVoltage_Volts)
                {
                    TTPLPFC_pwm_SwState.enum_pwmSwState =
                            pwmSwState_defaultState;
                    TTPLPFC_HAL_forceOSTPWMTrip_onAllPWM();

                    if(TTPLPFC_board_Status.enum_boardStatus ==
                            boardStatus_NoFault)
                    {
                        TTPLPFC_ac_volRmsEma_sensed_Volts = 0;
                    }
                    TTPLPFC_board_Status.enum_boardStatus =
                            boardStatus_InputUnderVoltageTrip;
                }

            //
            // Waiting for the grid connection after applying high enough
            // dc bus voltage (for grid-connected test)
            //
            if(TTPLPFC_vBus_sensed_Volts >= TTPLPFC_vBus_underVoltage_Volts &&
                    TTPLPFC_ac_volRms_sensed_Volts < (float32_t)75.0)
                    TTPLPFC_board_Status.enum_boardStatus =
                            boardStatus_NoGridConnection;

        #endif
    #endif

}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_overCurrentProtection)
static inline void TTPLPFC_overCurrentProtection()
{
     if((TTPLPFC_PWM_TRIP_STATUS(TTPLPFC_LOW_FREQ_PWM_BASE) &
                EPWM_TZ_INTERRUPT_DCAEVT1) != 0)
    {
        TTPLPFC_pwm_SwState.enum_pwmSwState = pwmSwState_defaultState;
        //
        // check if trip is flagged from X-bar inputs otherwise it has come from Gan FAULT
        //
        if( XBAR_getInputFlagStatus(TTPLPFC_IL1_PROTECTION_XBAR_FLAG1) == 1 )
        {
            TTPLPFC_board_Status.enum_boardStatus = boardStatus_OverCurrentTrip_Ph1_H;
        }
        else if(XBAR_getInputFlagStatus(TTPLPFC_IL1_PROTECTION_XBAR_FLAG2) == 1)
        {
            TTPLPFC_board_Status.enum_boardStatus = boardStatus_OverCurrentTrip_Ph1_L;
        }
        else if(XBAR_getInputFlagStatus(TTPLPFC_IL2_PROTECTION_XBAR_FLAG1) == 1)
        {
            TTPLPFC_board_Status.enum_boardStatus = boardStatus_OverCurrentTrip_Ph2_H;
        }
        else if(XBAR_getInputFlagStatus(TTPLPFC_IL2_PROTECTION_XBAR_FLAG2) == 1)
        {
            TTPLPFC_board_Status.enum_boardStatus = boardStatus_OverCurrentTrip_Ph2_L;
        }
        else
        {
           TTPLPFC_pwm_SwState.enum_pwmSwState = pwmSwState_defaultState;
           TTPLPFC_board_Status.enum_boardStatus = boardStatus_FAULTn;
        }
    }
}



#pragma FUNC_ALWAYS_INLINE(TTPLPFC_instrumentation)
static inline void TTPLPFC_instrumentation()
{

    //
    //Calculate RMS input voltage and input frequency
    //
    TTPLPFC_sine_mains.i = TTPLPFC_ac_cur_sensed_pu;
    TTPLPFC_sine_mains.v = TTPLPFC_ac_vol_sensed_pu;
    POWER_MEAS_SINE_ANALYZER_run(&TTPLPFC_sine_mains);
    TTPLPFC_ac_curRms_sensed_Amps =
            TTPLPFC_sine_mains.iRms * TTPLPFC_IL_MAX_SENSE;
    TTPLPFC_ac_volRms_sensed_Volts =
            TTPLPFC_sine_mains.vRms * TTPLPFC_VAC_MAX_SENSE;
    TTPLPFC_powerRms_Watts =
            TTPLPFC_sine_mains.pRms * TTPLPFC_VAC_MAX_SENSE *
            TTPLPFC_IL_MAX_SENSE;
    TTPLPFC_powerFactor = TTPLPFC_sine_mains.powerFactor;
    TTPLPFC_apparentPower_VA = TTPLPFC_sine_mains.vaRms *
            TTPLPFC_VAC_MAX_SENSE * TTPLPFC_IL_MAX_SENSE;
    TTPLPFC_acFreqAvg_Hz = TTPLPFC_sine_mains.acFreqAvg;
    TTPLPFC_ac_volEma_sensed_Volts = TTPLPFC_sine_mains.vEma *
            TTPLPFC_VAC_MAX_SENSE;
    TTPLPFC_EMAVG_MACRO(
            TTPLPFC_sine_mains.vRms, TTPLPFC_vRmsAvg_pu, (float32_t)0.000528);

}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_rlyOnOff)
static inline void TTPLPFC_rlyOnOff()
{
    #if TTPLPFC_DC_CHECK == 0
        if(fabsf(TTPLPFC_acSine) < 0.05f)
        {
            if(TTPLPFC_rlyConnect == 1)
            {
                TTPLPFC_HAL_closeRelay();
            }
        }

        if(TTPLPFC_rlyConnect == 0)
        {
            TTPLPFC_HAL_openRelay();
        }
    #else
        if(TTPLPFC_rlyConnect == 1)
        {
            TTPLPFC_HAL_closeRelay();
        }
        else
        {
            TTPLPFC_HAL_openRelay();
        }
    #endif
}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_phaseShedding)
static inline void TTPLPFC_phaseShedding()
{
    #if TTPLPFC_PHASE_SHEDDING_ENABLED == 1

    //
    //  Phase shedding
    //
        switch(TTPLPFC_interleaving_State.enum_interleavingState)
        {
        case interleavingState_3ph:
            if(TTPLPFC_ac_cur_ref_pu < TTPLPFC_iref2_pu - TTPLPFC_deltaIref_pu)
            {
                TTPLPFC_interleaving_State.enum_interleavingState =
                        interleavingState_2ph;

                //
                // 180 Degree Phase Shift for 2 phase interleaving
                //
                EPWM_setPhaseShift(TTPLPFC_HIGH_FREQ_PWM2_BASE,
                               ((uint16_t)((float32_t)TTPLPFC_PWM_PERIOD /
                                       (float32_t)(2.0))) - 2);
                EPWM_setCountModeAfterSync(TTPLPFC_HIGH_FREQ_PWM2_BASE,
                                     EPWM_COUNT_MODE_DOWN_AFTER_SYNC);

                //
                // Set High FREQ PWM 2 On and Set High FREQ PWM 3 Off
                //
                GPIO_setPinConfig(
                       TTPLPFC_HIGH_FREQ_PWM2_H_GPIO_PIN_CONFIG);
                GPIO_setPinConfig(
                       TTPLPFC_HIGH_FREQ_PWM2_L_GPIO_PIN_CONFIG);
                GPIO_setPinConfig(
                       TTPLPFC_HIGH_FREQ_PWM3_H_PHASE_SHEDDING_GPIO_PIN_CONFIG);
                GPIO_setPinConfig(
                       TTPLPFC_HIGH_FREQ_PWM3_L_PHASE_SHEDDING_GPIO_PIN_CONFIG);
            }

            break;

        case interleavingState_2ph:
            if(TTPLPFC_ac_cur_ref_pu > TTPLPFC_iref2_pu + TTPLPFC_deltaIref_pu)
            {
                TTPLPFC_interleaving_State.enum_interleavingState =
                        interleavingState_3ph;

                //
                // 120 Degree Phase Shift for 2 phase interleaving
                //
                EPWM_setPhaseShift(TTPLPFC_HIGH_FREQ_PWM2_BASE,
                               (2 + (uint16_t)((float32_t)TTPLPFC_PWM_PERIOD /
                                       (float32_t)(3.0))));
                EPWM_setCountModeAfterSync(TTPLPFC_HIGH_FREQ_PWM2_BASE,
                                           EPWM_COUNT_MODE_UP_AFTER_SYNC);

                //
                // Set High FREQ PWM 2 and 3 On
                //
                GPIO_setPinConfig(TTPLPFC_HIGH_FREQ_PWM2_H_GPIO_PIN_CONFIG);
                GPIO_setPinConfig(TTPLPFC_HIGH_FREQ_PWM2_L_GPIO_PIN_CONFIG);
                GPIO_setPinConfig(TTPLPFC_HIGH_FREQ_PWM3_H_GPIO_PIN_CONFIG);
                GPIO_setPinConfig(TTPLPFC_HIGH_FREQ_PWM3_L_GPIO_PIN_CONFIG);
            }

            else if(TTPLPFC_ac_cur_ref_pu <
                    TTPLPFC_iref1_pu - TTPLPFC_deltaIref_pu)
            {
                TTPLPFC_interleaving_State.enum_interleavingState =
                        interleavingState_1ph;

                //
                //  Set High FREQ PWM2 and 3 Off
                //
                GPIO_setPinConfig(
                       TTPLPFC_HIGH_FREQ_PWM2_H_PHASE_SHEDDING_GPIO_PIN_CONFIG);
                GPIO_setPinConfig(
                       TTPLPFC_HIGH_FREQ_PWM2_L_PHASE_SHEDDING_GPIO_PIN_CONFIG);
                GPIO_setPinConfig(
                       TTPLPFC_HIGH_FREQ_PWM3_H_PHASE_SHEDDING_GPIO_PIN_CONFIG);
                GPIO_setPinConfig(
                       TTPLPFC_HIGH_FREQ_PWM3_L_PHASE_SHEDDING_GPIO_PIN_CONFIG);
            }

            break;

        case interleavingState_1ph:

            if(TTPLPFC_ac_cur_ref_pu > TTPLPFC_iref1_pu + TTPLPFC_deltaIref_pu)
            {
                TTPLPFC_interleaving_State.enum_interleavingState
                = interleavingState_2ph;

                //
                //  180 Degree Phase Shift for 2 phase interleaving
                //
                EPWM_setPhaseShift(TTPLPFC_HIGH_FREQ_PWM2_BASE,
                              ((uint16_t)((float32_t)TTPLPFC_PWM_PERIOD /
                                      (float32_t)(2.0))) - 2);
                EPWM_setCountModeAfterSync(TTPLPFC_HIGH_FREQ_PWM2_BASE,
                                          EPWM_COUNT_MODE_DOWN_AFTER_SYNC);

                //
                //  Set High FREQ PWM 2 On and Set High FREQ PWM 3 Off
                //
                GPIO_setPinConfig(
                       TTPLPFC_HIGH_FREQ_PWM2_H_GPIO_PIN_CONFIG);
                GPIO_setPinConfig(
                       TTPLPFC_HIGH_FREQ_PWM2_L_GPIO_PIN_CONFIG);
                GPIO_setPinConfig(
                       TTPLPFC_HIGH_FREQ_PWM3_H_PHASE_SHEDDING_GPIO_PIN_CONFIG);
                GPIO_setPinConfig(
                       TTPLPFC_HIGH_FREQ_PWM3_L_PHASE_SHEDDING_GPIO_PIN_CONFIG);
            }

           break;
        }
    #else
        TTPLPFC_interleaving_State.enum_interleavingState =
                interleavingState_3ph;
    #endif
}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_runSFRAcollect)
static inline void TTPLPFC_runSFRAcollect(void)
{
    #if(TTPLPFC_SFRA_TYPE == TTPLPFC_SFRA_CURRENT )
        SFRA_F32_collect((float32_t*)&TTPLPFC_gi1_out,
                         (float32_t*)&TTPLPFC_ac_cur_sensed_pu);
    #endif
}

#if TTPLPFC_AEF_ENABLED == 1
#pragma FUNC_ALWAYS_INLINE(TTPLPFC_runAEF)
static inline void TTPLPFC_runAEF(void)
{
    AEF_updatePulseStatus();

    #if TTPLPFC_DC_CHECK == 0
    AEF_runClosedLoopAC(TTPLPFC_acSine);
    #else
    AEF_runClosedLoopDC();
    #endif

    AEF_updateInjectionLevel();
}
#endif

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_runISR1_lab1)
static inline void TTPLPFC_runISR1_lab1(void)
{

    //
    // Read Current and Voltage Measurements
    //
    TTPLPFC_read_individualCurrent();
    TTPLPFC_read_acVoltage();

    //
    // PWM Driver
    //
#pragma diag_suppress = 770
#pragma diag_suppress = 173

    #if TTPLPFC_PWM_AC_CHECK == 1
        TTPLPFC_rampGenerate();
        TTPLPFC_duty1_pu = TTPLPFC_duty_ref_pu * TTPLPFC_acSine;
        TTPLPFC_duty2_pu = TTPLPFC_duty1_pu;
        TTPLPFC_pwmDriver();
    #else
        TTPLPFC_duty1_pu = TTPLPFC_duty_DC_ref_pu;
        TTPLPFC_duty2_pu = TTPLPFC_duty_DC_ref_pu;
        TTPLPFC_pwmDriver_DC();
    #endif


    TTPLPFC_HAL_updatePWM(TTPLPFC_HIGH_FREQ_PWM1_BASE, TTPLPFC_duty1_pu);
    TTPLPFC_HAL_updatePWM(TTPLPFC_HIGH_FREQ_PWM2_BASE, TTPLPFC_duty2_pu);

#pragma diag_warning = 770
#pragma diag_warning = 173

    TTPLPFC_adaptiveDeadTime();

    // TTPLPFC_read_individualCurrent();

    TTPLPFC_read_busVoltage();

    TTPLPFC_SPLL();

    #if TTPLPFC_AEF_ENABLED == 1
    TTPLPFC_runAEF();
    #endif

    TTPLPFC_vBusSensedBuff[TTPLPFC_vBusSensedBuffIndex++] =
            TTPLPFC_vBus_sensed_pu;
    if(TTPLPFC_vBusSensedBuffIndex >= 10)
        TTPLPFC_vBusSensedBuffIndex = 0;

    TTPLPFC_HAL_updateDAC((TTPLPFC_acSine * (float32_t)0.5 +
                            (float32_t) 0.5));

    TTPLPFC_HAL_clearPWMInterruptFlag(
            TTPLPFC_C28x_CONTROL_ISR_TRIG_BASE);
}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_runISR1_lab2)
static inline void TTPLPFC_runISR1_lab2(void)
{
    //
    // Read Current and Voltage Measurements
    //
    TTPLPFC_read_individualCurrent();
    TTPLPFC_read_acVoltage();

    TTPLPFC_runCurrentLoop();

    //
    // PWM Driver
    //
#pragma diag_suppress = 770
#pragma diag_suppress = 173

    TTPLPFC_pwmDriver_DC();

    TTPLPFC_HAL_updatePWM(TTPLPFC_HIGH_FREQ_PWM1_BASE, TTPLPFC_duty1_pu);
    TTPLPFC_HAL_updatePWM(TTPLPFC_HIGH_FREQ_PWM2_BASE, TTPLPFC_duty2_pu);

#pragma diag_warning = 770
#pragma diag_warning = 173

    TTPLPFC_adaptiveDeadTime();

    TTPLPFC_acCurrentRef();

    TTPLPFC_runSFRAcollect();

    TTPLPFC_read_busVoltage();

    #if TTPLPFC_AEF_ENABLED == 1
    TTPLPFC_runAEF();
    #endif

    TTPLPFC_vBusSensedBuff[TTPLPFC_vBusSensedBuffIndex++] =
            TTPLPFC_vBus_sensed_pu;
    if(TTPLPFC_vBusSensedBuffIndex >= 10)
        TTPLPFC_vBusSensedBuffIndex = 0;

    TTPLPFC_HAL_clearPWMInterruptFlag(
            TTPLPFC_C28x_CONTROL_ISR_TRIG_BASE);

}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_runISR1_lab3)
static inline void TTPLPFC_runISR1_lab3(void)
{
    //
    // Read Current and Voltage Measurements
    //
    TTPLPFC_read_individualCurrent();
    TTPLPFC_read_acVoltage();

    TTPLPFC_runCurrentLoop();

    //
    // PWM Driver
    //
    #pragma diag_suppress = 770
    #pragma diag_suppress = 173

    TTPLPFC_pwmDriver();

    TTPLPFC_HAL_updatePWM(TTPLPFC_HIGH_FREQ_PWM1_BASE, TTPLPFC_duty1_pu);
    TTPLPFC_HAL_updatePWM(TTPLPFC_HIGH_FREQ_PWM2_BASE, TTPLPFC_duty2_pu);

    #pragma diag_warning = 770
    #pragma diag_warning = 173

    TTPLPFC_adaptiveDeadTime();

    TTPLPFC_SPLL();

    TTPLPFC_acCurrentRef();

    TTPLPFC_runSFRAcollect();

    TTPLPFC_read_individualCurrent();
    TTPLPFC_read_busVoltage();

    #if TTPLPFC_AEF_ENABLED == 1
    TTPLPFC_runAEF();
    #endif

    TTPLPFC_vBusSensedBuff[TTPLPFC_vBusSensedBuffIndex++] =
            TTPLPFC_vBus_sensed_pu;
    if(TTPLPFC_vBusSensedBuffIndex >= 10)
        TTPLPFC_vBusSensedBuffIndex = 0;

    TTPLPFC_HAL_updateDAC(TTPLPFC_spll_sine * (float32_t)0.5 +
                          (float32_t) 0.5);

#if TTPLPFC_LAB == 3 && TTPLPFC_DATALOGGER_ENABLE == 1
    //
    // Connect inputs of the Datalogger module
    //
    TTPLPFC_dataLogger();
#endif


    TTPLPFC_HAL_clearPWMInterruptFlag(
            TTPLPFC_C28x_CONTROL_ISR_TRIG_BASE);

}
#pragma FUNC_ALWAYS_INLINE(TTPLPFC_runISR1_lab4)
static inline void TTPLPFC_runISR1_lab4(void)
{
    //
    // Read Current and Voltage Measurements
    //
    TTPLPFC_read_individualCurrent();
    TTPLPFC_read_acVoltage();

    TTPLPFC_runCurrentLoop();


    //
    // PWM Driver
    //
    #pragma diag_suppress = 770
    #pragma diag_suppress = 173

    TTPLPFC_pwmDriver();

    //
    //Update PWM CMPA value
    //
    HWREGH(TTPLPFC_HIGH_FREQ_PWM1_BASE + EPWM_O_CMPA + 1) =  (uint32_t)((float32_t)(TTPLPFC_PWM_PERIOD / 2.0f) *
            fabsf(TTPLPFC_duty1_pu));
    HWREGH(TTPLPFC_HIGH_FREQ_PWM2_BASE + EPWM_O_CMPA + 1) =  (uint32_t)((float32_t)(TTPLPFC_PWM_PERIOD / 2.0f) *
            fabsf(TTPLPFC_duty2_pu));



    #pragma diag_warning = 770
    #pragma diag_warning = 173

    TTPLPFC_adaptiveDeadTime();

    TTPLPFC_SPLL();

    TTPLPFC_acCurrentRef();

    TTPLPFC_runSFRAcollect();

    TTPLPFC_read_busVoltage();


//ADD ###Begin_DCAEF Change all function names to DCAEF from AEF
    #if TTPLPFC_AEF_ENABLED == 1
    TTPLPFC_runAEF();
    #endif

    TTPLPFC_vBusSensedBuff[TTPLPFC_vBusSensedBuffIndex++] =
            TTPLPFC_vBus_sensed_pu;
    if(TTPLPFC_vBusSensedBuffIndex >= 10)
        TTPLPFC_vBusSensedBuffIndex = 0;

    TTPLPFC_HAL_clearPWMInterruptFlag(
            TTPLPFC_C28x_CONTROL_ISR_TRIG_BASE);
}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_runISR1_lab5)
static inline void TTPLPFC_runISR1_lab5(void)
{
    //
    // Read Current and Voltage Measurements
    //
    TTPLPFC_read_individualCurrent();
    TTPLPFC_read_acVoltage();

    //
    //Set duty for open loop test
    //
    TTPLPFC_duty1_pu = TTPLPFC_duty_DC_ref_pu;
    TTPLPFC_duty2_pu = TTPLPFC_duty_DC_ref_pu;

    //
    // PWM Driver
    //
#pragma diag_suppress = 770
#pragma diag_suppress = 173

    TTPLPFC_pwmDriver_DC();

    TTPLPFC_HAL_updatePWM(TTPLPFC_HIGH_FREQ_PWM1_BASE, TTPLPFC_duty1_pu);
    TTPLPFC_HAL_updatePWM(TTPLPFC_HIGH_FREQ_PWM2_BASE, TTPLPFC_duty2_pu);

#pragma diag_warning = 770
#pragma diag_warning = 173

    TTPLPFC_adaptiveDeadTime();

    TTPLPFC_read_individualCurrent();
    TTPLPFC_read_busVoltage();

    #if TTPLPFC_AEF_ENABLED == 1
    TTPLPFC_runAEF();
    #endif

    TTPLPFC_vBusSensedBuff[TTPLPFC_vBusSensedBuffIndex++] =
            TTPLPFC_vBus_sensed_pu;
    if(TTPLPFC_vBusSensedBuffIndex >= 10)
        TTPLPFC_vBusSensedBuffIndex = 0;

    TTPLPFC_HAL_clearPWMInterruptFlag(
            TTPLPFC_C28x_CONTROL_ISR_TRIG_BASE);
}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_runISR1_lab6)
static inline void TTPLPFC_runISR1_lab6(void)
{

    //
    // Read Current and Voltage Measurements
    //
    TTPLPFC_read_individualCurrent();
    TTPLPFC_read_acVoltage();

    TTPLPFC_rampGenerate();

    //
    //Set duty for open loop test
    //
    TTPLPFC_duty1_pu = TTPLPFC_duty_ref_pu * TTPLPFC_acSine;
    TTPLPFC_duty1_pu = TTPLPFC_duty2_pu;

    //
    // PWM Driver
    //
#pragma diag_suppress = 770
#pragma diag_suppress = 173

    TTPLPFC_pwmDriver();

    TTPLPFC_HAL_updatePWM(TTPLPFC_HIGH_FREQ_PWM1_BASE, TTPLPFC_duty1_pu);
    TTPLPFC_HAL_updatePWM(TTPLPFC_HIGH_FREQ_PWM2_BASE, TTPLPFC_duty2_pu);

#pragma diag_warning = 770
#pragma diag_warning = 173

    TTPLPFC_adaptiveDeadTime();

    TTPLPFC_SPLL();

    TTPLPFC_read_individualCurrent();
    TTPLPFC_read_busVoltage();

    #if TTPLPFC_AEF_ENABLED == 1
    TTPLPFC_runAEF();
    #endif

    TTPLPFC_vBusSensedBuff[TTPLPFC_vBusSensedBuffIndex++] =
            TTPLPFC_vBus_sensed_pu;
    if(TTPLPFC_vBusSensedBuffIndex >= 10)
        TTPLPFC_vBusSensedBuffIndex = 0;

    TTPLPFC_HAL_clearPWMInterruptFlag(
            TTPLPFC_C28x_CONTROL_ISR_TRIG_BASE);

}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_runISR1_lab7)
static inline void TTPLPFC_runISR1_lab7(void)
{

    //
    // Read Current and Voltage Measurements
    //
    TTPLPFC_read_individualCurrent();
    TTPLPFC_read_acVoltage();

    TTPLPFC_rampGenerate();

    TTPLPFC_runCurrentLoop();

    //
    // PWM Driver
    //
#pragma diag_suppress = 770
#pragma diag_suppress = 173

    TTPLPFC_pwmDriver_DC();

    TTPLPFC_HAL_updatePWM(TTPLPFC_HIGH_FREQ_PWM1_BASE, TTPLPFC_duty1_pu);
    TTPLPFC_HAL_updatePWM(TTPLPFC_HIGH_FREQ_PWM2_BASE, TTPLPFC_duty2_pu);

#pragma diag_warning = 770
#pragma diag_warning = 173

    TTPLPFC_adaptiveDeadTime();

    TTPLPFC_SPLL();

    TTPLPFC_acCurrentRef();

    TTPLPFC_runSFRAcollect();

    TTPLPFC_read_individualCurrent();
    TTPLPFC_read_busVoltage();

    #if TTPLPFC_AEF_ENABLED == 1
    TTPLPFC_runAEF();
    #endif

    TTPLPFC_vBusSensedBuff[TTPLPFC_vBusSensedBuffIndex++] =
            TTPLPFC_vBus_sensed_pu;
    if(TTPLPFC_vBusSensedBuffIndex >= 10)
        TTPLPFC_vBusSensedBuffIndex = 0;

    TTPLPFC_HAL_clearPWMInterruptFlag(
            TTPLPFC_C28x_CONTROL_ISR_TRIG_BASE);

}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_runISR1_lab8)
static inline void TTPLPFC_runISR1_lab8(void)
{

    //
    // Read Current and Voltage Measurements
    //
    TTPLPFC_read_individualCurrent();
    TTPLPFC_read_acVoltage();

    TTPLPFC_rampGenerate();

    TTPLPFC_runCurrentLoop();

    //
    // PWM Driver
    //
#pragma diag_suppress = 770
#pragma diag_suppress = 173

    TTPLPFC_pwmDriver();

    TTPLPFC_HAL_updatePWM(TTPLPFC_HIGH_FREQ_PWM1_BASE, TTPLPFC_duty1_pu);
    TTPLPFC_HAL_updatePWM(TTPLPFC_HIGH_FREQ_PWM2_BASE, TTPLPFC_duty2_pu);

#pragma diag_warning = 770
#pragma diag_warning = 173

    TTPLPFC_adaptiveDeadTime();

    TTPLPFC_SPLL();

    TTPLPFC_acCurrentRef();

    TTPLPFC_runSFRAcollect();

    TTPLPFC_read_individualCurrent();
    TTPLPFC_read_busVoltage();

    #if TTPLPFC_AEF_ENABLED == 1
    TTPLPFC_runAEF();
    #endif

    TTPLPFC_vBusSensedBuff[TTPLPFC_vBusSensedBuffIndex++] =
            TTPLPFC_vBus_sensed_pu;
    if(TTPLPFC_vBusSensedBuffIndex >= 10)
        TTPLPFC_vBusSensedBuffIndex = 0;

    TTPLPFC_HAL_clearPWMInterruptFlag(
            TTPLPFC_C28x_CONTROL_ISR_TRIG_BASE);

}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_runISR1_lab9)
static inline void TTPLPFC_runISR1_lab9(void)
{
    //
    // Read Current and Voltage Measurements
    //
    TTPLPFC_read_individualCurrent();
    TTPLPFC_read_acVoltage();

    TTPLPFC_runCurrentLoop();

    //
    // PWM Driver
    //
#pragma diag_suppress = 770
#pragma diag_suppress = 173

    TTPLPFC_pwmDriver();

    TTPLPFC_HAL_updatePWM(TTPLPFC_HIGH_FREQ_PWM1_BASE, TTPLPFC_duty1_pu);
    TTPLPFC_HAL_updatePWM(TTPLPFC_HIGH_FREQ_PWM2_BASE, TTPLPFC_duty2_pu);

#pragma diag_warning = 770
#pragma diag_warning = 173

    TTPLPFC_adaptiveDeadTime();

    TTPLPFC_SPLL();

    TTPLPFC_acCurrentRef();

    TTPLPFC_runSFRAcollect();

    TTPLPFC_read_individualCurrent();
    TTPLPFC_read_busVoltage();

    #if TTPLPFC_AEF_ENABLED == 1
   TTPLPFC_runAEF();
   #endif

    TTPLPFC_vBusSensedBuff[TTPLPFC_vBusSensedBuffIndex++] =
            TTPLPFC_vBus_sensed_pu;
    if(TTPLPFC_vBusSensedBuffIndex >= 10)
        TTPLPFC_vBusSensedBuffIndex = 0;

    TTPLPFC_HAL_clearPWMInterruptFlag(
            TTPLPFC_C28x_CONTROL_ISR_TRIG_BASE);

}

//
// Code to allow PWM output for only a small amount of time during debugging
//
#pragma FUNC_ALWAYS_INLINE(TTPLPFC_startupDebug)
static inline void TTPLPFC_startupDebug()
{
   //
   // during debug at startup output a low duty cycle on the active FET
   // new variables to control the state
   // TTPLPFC_timedRunCounter_ms
   //
   //
   if(TTPLPFC_autoStartSlew == 101)
   {
       if(TTPLPFC_manualStop == 1)
       {
           TTPLPFC_HAL_forceOSTPWMTrip_onAllPWM();
       }
       else
       {
           //
           // Only turn on the FETs for a few ms
           //
           if(TTPLPFC_timedRun_flag == 1)
           {
               TTPLPFC_timedRunCounter_ms = TTPLPFC_timedRunCounter_ms + 0.1;

               if(TTPLPFC_timedRunCounter_ms > TTPLPFC_timedRun_ms)
               {
                   TTPLPFC_manualStop = 1;
                   TTPLPFC_timedRun_flag = 0;
               }

           }

           //
           // slew the duty cycle update
           //
           if(TTPLPFC_duty_DC_ref_pu > 0)
           {
               if(TTPLPFC_duty_DC_ref_pu > TTPLPFC_duty_DC_ref_final_pu)
               {
                   TTPLPFC_duty_DC_ref_pu = TTPLPFC_duty_DC_ref_pu - TTPLPFC_dutySlew_pu;
               }

               TTPLPFC_duty_DC_ref_pu =
                       (TTPLPFC_duty_DC_ref_pu < TTPLPFC_duty_DC_ref_final_pu) ? TTPLPFC_duty_DC_ref_final_pu : TTPLPFC_duty_DC_ref_pu;
           }
           else
           {
               if(TTPLPFC_duty_DC_ref_pu < TTPLPFC_duty_DC_ref_final_pu)
               {
                   TTPLPFC_duty_DC_ref_pu = TTPLPFC_duty_DC_ref_pu + TTPLPFC_dutySlew_pu;
               }

               TTPLPFC_duty_DC_ref_pu =
                      (TTPLPFC_duty_DC_ref_pu > TTPLPFC_duty_DC_ref_final_pu) ? TTPLPFC_duty_DC_ref_final_pu : TTPLPFC_duty_DC_ref_pu;
           }

           //
           // if soft start of the duty is complete turn ON the SRs
           //
           if( TTPLPFC_duty_DC_ref_pu == TTPLPFC_duty_DC_ref_final_pu)
           {
               if(TTPLPFC_duty_DC_ref_pu > 0.0f)
               {
                   TTPLPFC_HAL_enableHighSideHFPWM();
               }
               else
               {

                   TTPLPFC_HAL_enableLowSideHFPWM();
               }
           }

       }

   }
}

//
// Voltage loop plus instrumentation code
//
#pragma FUNC_ALWAYS_INLINE(TTPLPFC_runISR2)
static inline void TTPLPFC_runISR2()
{

    int32_t k = 0;
    #if TTPLPFC_INSTRUMENTATION_ISR_RUNNING_ON == C28x_CORE
        EINT;
    #endif

    TTPLPFC_vBus_sensedFiltered = 0;

    for(k = 0; k < 10; k++)
    {
        TTPLPFC_vBus_sensedFiltered+= TTPLPFC_vBusSensedBuff[k];
    }

    TTPLPFC_vBus_sensedFiltered = TTPLPFC_vBus_sensedFiltered * 0.1f;

    TTPLPFC_vBus_sensedFiltered_notch1 =
            TTPLPFC_NOTCH_2P2Z_RUN(&TTPLPFC_notch1,
                                   TTPLPFC_vBus_sensedFiltered);
    TTPLPFC_vBus_sensedFiltered_notch2 =
            TTPLPFC_NOTCH_2P2Z_RUN(&TTPLPFC_notch2,
                                   TTPLPFC_vBus_sensedFiltered_notch1);

//    TTPLPFC_vBus_sensedFiltered_notch1 = TTPLPFC_vBus_sensedFiltered;
//    TTPLPFC_vBus_sensedFiltered_notch2 = TTPLPFC_vBus_sensedFiltered;

    TTPLPFC_read_acVoltage_separateResistor();

    TTPLPFC_read_systemSignals();

    //
    // Voltage Loop
    //
    #if(TTPLPFC_VOLTAGE_LOOP_CLOSED == 1)
        TTPLPFC_runVoltageLoop();
    #endif

    TTPLPFC_EMAVG_MACRO(TTPLPFC_vBus_sensedFiltered_notch2,
                        TTPLPFC_vBusAvg_pu, (float32_t)0.000528);

    TTPLPFC_EMAVG_MACRO((fabsf(TTPLPFC_ac_vol_sensed_pu)
                        * TTPLPFC_VAC_MAX_SENSE),
                        TTPLPFC_ac_volRmsEma_sensed_Volts, (float32_t)0.00005);


#if TTPLPFC_LAB != 3 && TTPLPFC_DATALOGGER_ENABLE == 1
    //
    // Connect inputs of the Datalogger module
    //
    TTPLPFC_dataLogger();
#endif

#if TTPLPFC_AUTO_START == 1
    TTPLPFC_rlyConnectFlag();
#endif

    TTPLPFC_vBus_sensed_Volts = TTPLPFC_vBus_sensedFiltered_notch2 *
                                TTPLPFC_VDCBUS_MAX_SENSE;

    TTPLPFC_iL1_sensed_Amps = TTPLPFC_iL1_sensed_pu * TTPLPFC_IL_MAX_SENSE;

    TTPLPFC_iL2_sensed_Amps = TTPLPFC_iL2_sensed_pu * TTPLPFC_IL_MAX_SENSE;

    TTPLPFC_ac_cur_sensed_pu = TTPLPFC_iL1_sensed_pu + TTPLPFC_iL2_sensed_pu;
    TTPLPFC_ac_cur_sensed_Amps = TTPLPFC_ac_cur_sensed_pu * TTPLPFC_IL_MAX_SENSE;

    TTPLPFC_ac_vol_sensed_Volts = (TTPLPFC_ac_vol_sensed_pu) *
                                  TTPLPFC_VAC_MAX_SENSE;

    //
    // Over voltage, under voltage and over current protection flags
    //
#if TTPLPFC_LAB == 1 || TTPLPFC_AUTO_START == 0
    //
    // Protection is not enabled
    //
#else
    TTPLPFC_underVoltageProtection();
#endif
    TTPLPFC_overVoltageProtection();
    TTPLPFC_overCurrentProtection();

    //
    //Calculate RMS input voltage and input frequency
    //
    TTPLPFC_instrumentation();

    TTPLPFC_rlyOnOff();

    TTPLPFC_phaseShedding();

    TTPLPFC_HAL_updateGaNTemp();

    //
    // During Lab1 provide an option to start the PWM
    // for a small amount of time
    //
#if TTPLPFC_DC_CHECK == 1 &&  TTPLPFC_RAMPED_DUTY_STARTUP == 1
    TTPLPFC_startupDebug();
#endif

}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_detectZeroCrossingClearPWMTrip)
static inline void  TTPLPFC_detectZeroCrossingClearPWMTrip(
        uint32_t base1, uint32_t base2, uint32_t base3, uint32_t base4)
{
    if((TTPLPFC_acSinePrev <= (float32_t)(0.00)) &&
            (TTPLPFC_acSine > (float32_t)(0.00)))
    {
        TTPLPFC_zeroCrossDetectFlag = 1;
    }
    else
    {
        TTPLPFC_zeroCrossDetectFlag = 0;
    }

    if(TTPLPFC_clearTrip == 1 && TTPLPFC_zeroCrossDetectFlag == 1)
    {
        TTPLPFC_pwm_SwState.enum_pwmSwState = pwmSwState_normalOperation;
        TTPLPFC_board_Status.enum_boardStatus = boardStatus_NoFault;
        TTPLPFC_clearTrip = 0;
    }

}

#pragma FUNC_ALWAYS_INLINE(TTPLPFC_computeISRloading)
static inline void TTPLPFC_computeISRloading(void)
{
    //
    // Get the capture counts for the ISR1 for the last two
    // ISRs, these are logged by reading the capture values
    //
    TTPLPFC_ISR1cap1Count = HWREG(TTPLPFC_PROFILING1_ECAP + ECAP_O_CAP1);
    TTPLPFC_ISR1cap2Count = HWREG(TTPLPFC_PROFILING1_ECAP + ECAP_O_CAP2);
    TTPLPFC_ISR1cap3Count = HWREG(TTPLPFC_PROFILING1_ECAP + ECAP_O_CAP3);
    TTPLPFC_ISR1cap4Count = HWREG(TTPLPFC_PROFILING1_ECAP + ECAP_O_CAP4);

    //
    // Capture ISR1 loading and log max value
    // look back at the last 2 captures to do the same
    //
    TTPLPFC_ISR1_Loading =  ((float32_t)TTPLPFC_ISR1cap1Count /
            ((float32_t)TTPLPFC_ISR1cap1Count + (float32_t)TTPLPFC_ISR1cap2Count) );

    if( TTPLPFC_ISR1_Loading > TTPLPFC_ISR1_LoadingMax )
    {
        TTPLPFC_ISR1_LoadingMax = TTPLPFC_ISR1_Loading;
    }

    TTPLPFC_ISR1_Loading =  ((float32_t)TTPLPFC_ISR1cap3Count /
            ((float32_t)TTPLPFC_ISR1cap3Count + (float32_t)TTPLPFC_ISR1cap4Count) );

    if( TTPLPFC_ISR1_Loading > TTPLPFC_ISR1_LoadingMax )
    {
        TTPLPFC_ISR1_LoadingMax = TTPLPFC_ISR1_Loading;
    }

    if( TTPLPFC_ISR1cap1Count > TTPLPFC_ISR1_capCountMax)
    {
       TTPLPFC_ISR1_capCountMax = TTPLPFC_ISR1cap1Count;
    }

    if( TTPLPFC_ISR1cap3Count > TTPLPFC_ISR1_capCountMax)
    {
      TTPLPFC_ISR1_capCountMax = TTPLPFC_ISR1cap3Count;
    }

    //
    // Compute the ISR1 capture average over 10 past samples
    //
    TTPLPFC_ISR1cap1CountAvg = TTPLPFC_ISR1cap1CountAvg +
                           0.1f * (TTPLPFC_ISR1cap1Count - TTPLPFC_ISR1cap1CountAvg);

    //
    // Get the capture counts for the ISR2 for the last two
    // ISRs, these are logged by reading the capture values
    //
    TTPLPFC_ISR2cap1Count = HWREG(TTPLPFC_PROFILING2_ECAP + ECAP_O_CAP1);
    TTPLPFC_ISR2cap2Count = HWREG(TTPLPFC_PROFILING2_ECAP + ECAP_O_CAP2);
    TTPLPFC_ISR2cap3Count = HWREG(TTPLPFC_PROFILING2_ECAP + ECAP_O_CAP3);
    TTPLPFC_ISR2cap4Count = HWREG(TTPLPFC_PROFILING2_ECAP + ECAP_O_CAP4);

    TTPLPFC_ISR2_Loading = (
             (((float32_t)TTPLPFC_ISR2cap1Count ) /
              ((float32_t)TTPLPFC_ISR2cap1Count + (float32_t)TTPLPFC_ISR2cap2Count)) +
             (((float32_t)TTPLPFC_ISR2cap3Count )  /
              ((float32_t)TTPLPFC_ISR2cap3Count + (float32_t)TTPLPFC_ISR2cap4Count)))
                      * 0.5f;

    //
    // Further average over 10 samples of the average of 2 captures
    //
    TTPLPFC_ISR2_LoadingAvg = TTPLPFC_ISR2_LoadingAvg + (TTPLPFC_ISR2_Loading - TTPLPFC_ISR2_LoadingAvg) * 0.1f ;

    //
    // Subtract the average loading of the nested ISR1 interrupts from ISR2 Loading
    //
    TTPLPFC_ISR2_LoadingAvg_accountingForNesting =  TTPLPFC_ISR2_LoadingAvg
            -( TTPLPFC_ISR1_nestsAvg * TTPLPFC_ISR1_Loading *
              (float32_t)TTPLPFC_INSTRUMENTATION_ISR_FREQUENCY/(float32_t)TTPLPFC_CONTROL_ISR_FREQUENCY );
}



#ifdef __cplusplus
}
#endif                                  /* extern "C" */


#endif
