//#############################################################################
//
// FILE:   clllc.h
//
// TITLE: This is the solution header file.
//
//#############################################################################
// $TI Release: obc_7_4kw_ttplpfc_clllc v1.00.01.00 $
// $Release Date: Fri Dec 16 18:13:38 CST 2022 $
// $Copyright:
// Copyright (C) 2022 Texas Instruments Incorporated - http://www.ti.com/
//
// ALL RIGHTS RESERVED
// $
//#############################################################################

#ifndef CLLLC_H
#define CLLLC_H

#ifdef __cplusplus

extern "C" {
#endif

//
// the includes & defines
//
#include <stdint.h>
#include <stddef.h>

#ifndef __TMS320C28XX_CLA__
#include <math.h>
#else
#include <CLAmath.h>
#endif

//
// this is the file generated by the powerSUITE page for this system
//
#include "clllc_settings.h"
#include "clllc_hal.h"

//
// Library header files
// DCL Library is used for the controller implementation
// GI -> DF13,
// GV -> DF13,
//

#ifndef __TMS320C28XX_CLA__
#include "DCLF32.h"
#define CLLLC_GI DCL_DF13
#define CLLLC_GV DCL_DF13

//
// GI on C28x ,run DCL_DF13 routines
//
#define CLLLC_GI_IMMEDIATE_RUN DCL_runDF13_C5
#define CLLLC_GI_PRECOMPUTE_RUN DCL_runDF13_C6

//
// GV on C28x ,run DCL_DF13 routines
//
#define CLLLC_GV_RUN DCL_runDF13_C4
#define CLLLC_GV_IMMEDIATE_RUN DCL_runDF13_C5
#define CLLLC_GV_PRECOMPUTE_RUN DCL_runDF13_C6

#else
#include "DCLCLA.h"
#define CLLLC_GI DCL_DF13_CLA
#define CLLLC_GV DCL_DF13_CLA

//
// GI on C28x ,run DCL_DF13 routines
//
#define CLLLC_GI_IMMEDIATE_RUN CLLLC_runDF13_L5
#define CLLLC_GI_PRECOMPUTE_RUN CLLLC_runDF13_L6

//
// GV on C28x ,run DCL_DF13 routines
//
#define CLLLC_GV_IMMEDIATE_RUN CLLLC_runDF13_L5
#define CLLLC_GV_PRECOMPUTE_RUN CLLLC_runDF13_L6

#pragma FUNC_ALWAYS_INLINE(CLLLC_runDF13_L5)
#pragma FUNC_ALWAYS_INLINE(CLLLC_runDF13_L6)

//
//! \brief          Executes an immediate 3rd order Direct Form 1 controller on
//!                 the FPU32, Implemented as inline C function
//! \param[in] p    Pointer to the DCL_DF13 controller structure
//! \param[in] ek   The servo error
//! \param[in] vk   The partial pre-computed control effort
//! \return         The control effort
//!
static inline float32_t CLLLC_runDF13_L5(DCL_DF13_CLA *p,
                                             float32_t ek,
                                             float32_t vk)
{
    p->d4 = (ek * p->b0) + vk;

    return(p->d4);
}

//
//! \brief          Executes a partial pre-computed 3rd order
//!                 Direct Form 1 controller on the FPU32
//!                 Implemented as inline C function
//!                 Note: d0 not used
//! \param[in] p    Pointer to the DCL_DF13 controller structure
//! \param[in] ek   The servo error
//! \param[in] uk   The controller output in the previous sample interval
//! \return         The control effort
//!
//
static inline float32_t CLLLC_runDF13_L6(DCL_DF13_CLA *p,
                                             float32_t ek,
                                             float32_t uk)
{
    float32_t v9;

    v9 = (ek * p->b1) + (p->d1 * p->b2) + (p->d2 * p->b3)
         - (uk * p->a1) - (p->d5 * p->a2) - (p->d6 * p->a3);
    p->d2 = p->d1;
    p->d1 = ek;
    p->d6 = p->d5;
    p->d5 = uk;

    return(v9);
}

#endif

#include "dlog_4ch.h"
#include "emavg.h"

#pragma FUNC_ALWAYS_INLINE(EPWM_setActionQualifierContSWForceAction)

#ifndef __TMS320C28XX_CLA__
#include "sfra_f32.h"
#include "sfra_gui_scicomms_driverlib.h"
#define CLLLC_SFRA_INJECT SFRA_F32_inject
#define CLLLC_SFRA_COLLECT SFRA_F32_collect
#else
#define CLLLC_SFRA_INJECT(m)    m
#define CLLLC_SFRA_COLLECT(m, n)
#endif

#ifndef INT_EPWM1
#define INT_EPWM1                   0x00300301U // 3.1 - ePWM1 Interrupt
#endif
//
// Function to run the ISR3, for details see dataflow diagram in the user guide
//
void CLLLC_runISR3(void);

interrupt void ISR1(void);
interrupt void ISR1_phaseShift(void);

//
// Function initialize the global variables
//
void CLLLC_initGlobalVariables(void);

//
// Function reads the trip flags and updates the board status enum type variable
//
void CLLLC_updateBoardStatus(void);

//
//
//
void CLLLC_runSFRABackGroundTasks(void);


//
//
//
void CLLLC_setBuildLevelIndicatorVariable(void);
void CLLLC_changeSynchronousRectifierPwmBehavior(uint16_t powerFlow);

#ifndef __TMS320C28XX_CLA__
void CLLLC_setupSFRA();
#else
#endif

//
// typedefs
//

typedef union{
    enum
    {
        CLLLC_Lab1 = 0,
        CLLLC_Lab1_CLA = 1,
        CLLLC_Lab2 = 2,
        CLLLC_Lab2_CLA = 3,
        CLLLC_Lab3 = 4,
        CLLLC_Lab3_CLA = 5,
        CLLLC_Lab4 = 6,
        CLLLC_Lab4_CLA = 7,
        CLLLC_Lab5 = 8,
        CLLLC_Lab5_CLA = 9,
        CLLLC_Lab6 = 10,
        CLLLC_Lab6_CLA = 11,
        CLLLC_Lab7 = 12,
        CLLLC_Lab7_CLA = 13,
        CLLLC_Lab8 = 14,
        CLLLC_Lab8_CLA = 15,
        CLLLC_undefinedLab = 12,
    }CLLLC_Lab_Enum;
    int32_t pad;
}CLLLC_Lab_EnumType;

extern  CLLLC_Lab_EnumType CLLLC_lab;

typedef union{
    enum
    {
        noTrip = 0,
        primOverCurrentTrip = 1,
        secOverCurrentTrip = 2,
        primOverVoltageTrip = 3,
        secOverVoltageTrip = 4,
        primTankOverCurrentTrip = 5,
        ganFaultTrip = 6,
    }CLLLC_TripFlag_Enum;
    int32_t pad;
}CLLLC_TripFlag_EnumType;

extern  CLLLC_TripFlag_EnumType CLLLC_TripFlag;

typedef union{
    enum
    {
        pwmSwState_disabledAll = 0,
        pwmSwState_synchronousRectification_OFF = 1,
        pwmSwState_synchronousRectification_fixedDuty = 2,
        pwmSwState_synchronousRectification_active = 3
    }CLLLC_PwmSwState_Enum;
    int32_t pad;
}CLLLC_PwmSwState_EnumType;

extern  CLLLC_PwmSwState_EnumType CLLLC_pwmSwStateActive, CLLLC_pwmSwState;

typedef union{
    enum
    {
        powerFlow_PrimToSec = CLLLC_POWER_FLOW_PRIM_SEC,
        powerFlow_SecToPrim = CLLLC_POWER_FLOW_SEC_PRIM,
        powerFlow_intermediateState = CLLLC_POWER_FLOW_TRANSTION_STAGE,
    }CLLLC_PowerFlowState_Enum;
    int32_t pad;
}CLLLC_PowerFlowState_EnumType;

extern  CLLLC_PowerFlowState_EnumType CLLLC_powerFlowStateActive,
                                  CLLLC_powerFlowState;

typedef union{
    enum
    {
        ac_dc_OFF = 0,
        ac_dc_PFC = 1,
        ac_dc_INV = 2,
    }CLLLC_CommandSentTo_AC_DC_Enum;
    int32_t pad;
}CLLLC_CommandSentTo_AC_DC_EnumType;

extern  CLLLC_CommandSentTo_AC_DC_EnumType CLLLC_commandSentTo_AC_DC;

typedef union{
    enum
    {
        freqMode = 0,
        phaseMode = 1
    }CLLLC_ModulationMode_Enum;
    int32_t pad;
}CLLLC_ModulationMode_EnumType;

extern  CLLLC_ModulationMode_EnumType CLLLC_ModulationMode;

typedef union{
    enum
    {
        manual_stop = 0,
        do_nothing = 1,
        start_converter = 2,
        clear_pwm_trip = 3,
        phase_shifting = 4,
        freq_shifting = 5,
        free_run = 6,
        timed_run = 7,
        timed_run_stop = 8,
        run_end = 9
    }CLLLC_StatupState_Enum;
    int32_t pad;
}CLLLC_StartupState_EnumType;

//
// globals
//

extern CLLLC_GI CLLLC_gi;
extern float32_t CLLLC_giOut;
extern float32_t CLLLC_giError;
extern float32_t CLLLC_giPartialComputedValue;

extern CLLLC_GV CLLLC_gv;
extern float32_t CLLLC_gvOut;
extern float32_t CLLLC_gvError;
extern float32_t CLLLC_gvPartialComputedValue;

//
// Flags for clearing trips and closing the loop
//
extern int32_t CLLLC_closeGiLoop;
extern int32_t CLLLC_closeGvLoop;
extern int32_t CLLLC_clearTrip;

extern float32_t CLLLC_pwmFrequency_Hz;
extern float32_t CLLLC_pwmFrequencyPrev_Hz;

extern float32_t CLLLC_pwmPeriodRef_pu;
extern float32_t CLLLC_pwmPeriod_pu;
extern float32_t CLLLC_pwmPeriodSlewed_pu;
extern float32_t CLLLC_pwmPeriodMin_pu;
extern float32_t CLLLC_pwmPeriodMax_pu;
extern float32_t CLLLC_pwmPeriodMax_ticks;
extern uint32_t CLLLC_pwmPeriod_ticks;

//
// 1- Primary Side (PFC-Inv/Bus)
//
extern float32_t CLLLC_iPrimSensed_Amps;
extern float32_t CLLLC_iPrimSensed_pu;
extern float32_t CLLLC_iPrimSensedOffset_pu;
extern float32_t CLLLC_iPrimSensedCalIntercept_pu;
extern float32_t CLLLC_iPrimSensedCalXvariable_pu;
extern EMAVG CLLLC_iPrimSensedAvg_pu;

extern float32_t CLLLC_iPrimTankSensed_Amps;
extern float32_t CLLLC_iPrimTankSensed_pu;
extern float32_t CLLLC_iPrimTankSensedOffset_pu;
extern float32_t CLLLC_iPrimTankSensedCalIntercept_pu;
extern float32_t CLLLC_iPrimTankSensedCalXvariable_pu;
extern EMAVG CLLLC_iPrimTankSensedAvg_pu;

extern float32_t CLLLC_vPrimSensed_Volts;
extern float32_t CLLLC_vPrimSensed_pu;
extern float32_t CLLLC_vPrimSensedOffset_pu;
extern EMAVG CLLLC_vPrimSensedAvg_pu;

extern float32_t CLLLC_vPrimRef_Volts;
extern float32_t CLLLC_vPrimRef_pu;
extern float32_t CLLLC_vPrimRefSlewed_pu;

extern float32_t CLLLC_pwmDutyPrimRef_pu;
extern float32_t CLLLC_pwmDutyPrim_pu;
extern uint32_t CLLLC_pwmDutyAPrim_ticks;
extern uint32_t CLLLC_pwmDutyBPrim_ticks;

extern float32_t CLLLC_pwmDeadBandREDPrimRef_ns;
extern uint32_t CLLLC_pwmDeadBandREDPrim_ticks;

extern float32_t CLLLC_pwmDeadBandFEDPrimRef_ns;
extern uint32_t CLLLC_pwmDeadBandFEDPrim_ticks;

//
// 2-Secondary side (Battery)
//
extern uint32_t CLLLC_iSecSenseDiag;

extern float32_t CLLLC_iSecSensed_Amps;
extern float32_t CLLLC_iSecSensed_pu;
extern float32_t CLLLC_iSecSensedOffset_pu;
extern float32_t CLLLC_iSecSensedCalIntercept_pu;
extern float32_t CLLLC_iSecSensedCalXvariable_pu;
extern EMAVG CLLLC_iSecSensedAvg_pu;

extern float32_t CLLLC_iSecRef_Amps;
extern float32_t CLLLC_iSecRef_pu;
extern float32_t CLLLC_iSecRefSlewed_pu;

extern float32_t CLLLC_vSecSensed_Volts;
extern float32_t CLLLC_vSecSensed_pu;
extern float32_t CLLLC_vSecSensedOffset_pu;

extern float32_t CLLLC_vSecRef_Volts;
extern float32_t CLLLC_vSecRef_pu;
extern float32_t CLLLC_vSecRefSlewed_pu;
extern EMAVG CLLLC_vSecSensedAvg_pu;

extern float32_t CLLLC_pwmDutySecRef_pu;
extern float32_t CLLLC_pwmDutySec_pu;
extern uint32_t CLLLC_pwmDutyASec_ticks;
extern uint32_t CLLLC_pwmDutyBSec_ticks;
extern float32_t CLLLC_pwmDutySecAdjust_pu;

extern float32_t CLLLC_pwmDeadbandREDSec_ns;
extern uint16_t CLLLC_pwmDeadbandREDSec_ticks;

extern float32_t CLLLC_pwmDeadBandFEDSec_ns;
extern uint16_t CLLLC_pwmDeadbandFEDSec_ticks;

extern float32_t CLLLC_pwmPhaseShiftPrimSecRef_ns;
extern float32_t CLLLC_pwmPhaseShiftPrimSec_ns;
extern int32_t CLLLC_pwmPhaseShiftPrimSec_ticks;
extern int16_t CLLLC_pwmPhaseShiftPrimSec_countDirection;

extern float32_t CLLLC_pwmPhaseShiftPrimLegsRef_pu;
extern float32_t CLLLC_pwmPhaseShiftPrimLegs_pu;
extern float32_t CLLLC_pwmPhaseShiftPrimLegs_ns;
extern int32_t CLLLC_pwmPhaseShiftPrimLegs_ticks;
extern uint16_t CLLLC_pwmPhaseShiftPrimLegs_HiResticks;
extern int16_t CLLLC_pwmPhaseShiftPrimLegs_countDirection;


extern CLLLC_HAL_GaNTemp_Struct CLLLC_HAL_GaNTemp_C;

extern uint16_t CLLLC_enableLC;

extern uint16_t CLLLC_modeChangeFlag;

extern CLLLC_TripFlag_EnumType CLLLC_tripFlag;

extern uint16_t CLLLC_pwmISRTrig_ticks;
extern uint16_t CLLLC_pwmISRTrig_ticks_prev;

//extern uint32_t CLLLC_cla_task_counter;

extern uint32_t CLLLC_slewSCIcommand;

#ifndef __TMS320C28XX_CLA__
//
// datalogger
//
#if CLLLC_DATALOGGER_ENABLE == 1
extern DLOG_4CH CLLLC_dLog1;
extern float32_t CLLLC_dBuff1[100],
                 CLLLC_dBuff2[100],
                 CLLLC_dBuff3[100],
                 CLLLC_dBuff4[100];
extern float32_t CLLLC_dVal1,
                 CLLLC_dVal2,
                 CLLLC_dVal3,
                 CLLLC_dVal4;
extern volatile float32_t CLLLC_dlogTrigger;
#endif

#if CLLLC_SFRA_TYPE != CLLLC_SFRA_DISABLED
extern float32_t CLLLC_plantMagVect[CLLLC_SFRA_FREQ_LENGTH];
extern float32_t CLLLC_plantPhaseVect[CLLLC_SFRA_FREQ_LENGTH];
extern float32_t CLLLC_olMagVect[CLLLC_SFRA_FREQ_LENGTH];
extern float32_t CLLLC_olPhaseVect[CLLLC_SFRA_FREQ_LENGTH];
extern float32_t CLLLC_freqVect[CLLLC_SFRA_FREQ_LENGTH];
#endif

extern SFRA_F32 CLLLC_sfra1;
extern int16_t SerialCommsTimer;
extern int16_t initializationFlag;
extern int16_t *varSetTxtList[];
extern int16_t *varSetBtnList[];
extern int16_t *varSetSldrList[];
extern int16_t *varGetList[];
extern int32_t *arrayGetList[];
extern int16_t *dataGetList[];
extern uint32_t *dataSetList[];

extern int16_t CommsOKflg, SerialCommsTimer;
#endif

//
// the function prototypes
//


//
// Read Current and Voltage Measurements
//
#pragma FUNC_ALWAYS_INLINE(CLLLC_readSensedSignalsPrimToSecPowerFlow)
static inline void CLLLC_readSensedSignalsPrimToSecPowerFlow(void)
{
    //
    // The below is put under the following tag, as it is not used currently in the combined project
    //
#if CLLLC_STANDALONE_MODULE == 1
    CLLLC_iPrimSensed_pu = ((float32_t)CLLLC_IPRIM_ADCREAD *
                                       CLLLC_ADC_PU_SCALE_FACTOR
                   - CLLLC_iPrimSensedOffset_pu) * -2.0f;
#endif

    CLLLC_iSecSensed_pu =  ((float32_t)CLLLC_ISEC_OVERSAMPLE_ADCREAD *
                                       CLLLC_ADC_PU_SCALE_FACTOR
                   - CLLLC_iSecSensedOffset_pu) * 2.0f;

#if CLLLC_STANDALONE_MODULE == 1

    CLLLC_vPrimSensed_pu = ((float32_t)CLLLC_VPRIM_OVERSAMPLE_ADCREAD *
                                       CLLLC_ADC_PU_SCALE_FACTOR
                   - CLLLC_vPrimSensedOffset_pu);
#endif

    CLLLC_vSecSensed_pu =  ( (float32_t)CLLLC_VSEC_OVERSAMPLE_ADCREAD *
                                        CLLLC_ADC_PU_SCALE_FACTOR
                   - CLLLC_vSecSensedOffset_pu);

    CLLLC_vSecSensed_pu = CLLLC_vSecSensed_pu *
                  (CLLLC_VSEC_MAX_SENSE_VOLTS / CLLLC_VSEC_OPTIMAL_RANGE_VOLTS);

    CLLLC_iSecSensed_pu = (CLLLC_iSecSensed_pu *
                           CLLLC_iSecSensedCalXvariable_pu) +
                           CLLLC_iSecSensedCalIntercept_pu;
    CLLLC_iPrimSensed_pu = (CLLLC_iPrimSensed_pu *
                            CLLLC_iPrimSensedCalXvariable_pu) +
                            CLLLC_iPrimSensedCalIntercept_pu;
}

#pragma FUNC_ALWAYS_INLINE(CLLLC_readSensedSignalsSecToPrimPowerFlow)
static inline void CLLLC_readSensedSignalsSecToPrimPowerFlow(void)
{
    CLLLC_iPrimSensed_pu = ((float32_t)CLLLC_IPRIM_ADCREAD *
                                       CLLLC_ADC_PU_SCALE_FACTOR
                   - CLLLC_iPrimSensedOffset_pu) * -2.0f;

    CLLLC_iSecSensed_pu =  ((float32_t)CLLLC_ISEC_ADCREAD *
                                       CLLLC_ADC_PU_SCALE_FACTOR
                   - CLLLC_iSecSensedOffset_pu) * 2.0f;
//    CLLLC_vPrimSensed_pu = ((float32_t)CLLLC_VPRIM_OVERSAMPLE_ADCREAD *
//                                       CLLLC_ADC_PU_SCALE_FACTOR
//                   - CLLLC_vPrimSensedOffset_pu);
    CLLLC_vSecSensed_pu =  ( (float32_t)CLLLC_VSEC_ADCREAD *
                                        CLLLC_ADC_PU_SCALE_FACTOR
                   - CLLLC_vSecSensedOffset_pu);

    CLLLC_vSecSensed_pu = CLLLC_vSecSensed_pu *
                  (CLLLC_VSEC_MAX_SENSE_VOLTS / CLLLC_VSEC_OPTIMAL_RANGE_VOLTS);

    CLLLC_iSecSensed_pu = (CLLLC_iSecSensed_pu *
                           CLLLC_iSecSensedCalXvariable_pu) +
                           CLLLC_iSecSensedCalIntercept_pu;
    CLLLC_iPrimSensed_pu = (CLLLC_iPrimSensed_pu *
                            CLLLC_iPrimSensedCalXvariable_pu) +
                            CLLLC_iPrimSensedCalIntercept_pu;
}

#pragma FUNC_ALWAYS_INLINE(CLLLC_calculatePWMDutyPeriodPhaseShiftTicks_primToSecPowerFlow_phaseShiftMode)
static inline void CLLLC_calculatePWMDutyPeriodPhaseShiftTicks_primToSecPowerFlow_phaseShiftMode(void)
{
    uint32_t temp;

    CLLLC_pwmDutyPrim_pu = CLLLC_pwmDutyPrimRef_pu;
    CLLLC_pwmDutySec_pu = CLLLC_pwmDutySecRef_pu;
    CLLLC_pwmPhaseShiftPrimSec_ns = CLLLC_pwmPhaseShiftPrimSecRef_ns;
    CLLLC_pwmPhaseShiftPrimLegs_pu = CLLLC_pwmPhaseShiftPrimLegsRef_pu;

    //
    // First calculate the hi-res ticks for the PWM
    // for this multiply by 2^16 , and divide by 1 (using left shift)
    // as the PWM is up down count mode
    //
    temp = ((uint32_t)(((float32_t)(CLLLC_pwmPeriodSlewed_pu *
                                   CLLLC_pwmPeriodMax_ticks) *
                       (float32_t)TWO_RAISED_TO_THE_POWER_SIXTEEN)))>> 1;

    //
    // next zero the lower 8 bits, as they are not part of TBPRDHR register
    //
    CLLLC_pwmPeriod_ticks = temp & 0xFFFFFF00;

    //
    // for hi-res the duty needs to set around period hence calculate
    // duty ticks as (period *(1-duty))
    //
    CLLLC_pwmDutyAPrim_ticks = (uint32_t)((float32_t)CLLLC_pwmPeriod_ticks *
                                         (float32_t)
                                         (1 - fabsf(CLLLC_pwmDutyPrim_pu)));

    CLLLC_pwmDutyBPrim_ticks = CLLLC_pwmDutyAPrim_ticks;

    //
    // the below is to get around the errata in HRPWM
    //
    if((CLLLC_pwmDutyAPrim_ticks & 0x00FF00) == 0)
    {
        CLLLC_pwmDutyAPrim_ticks = CLLLC_pwmDutyAPrim_ticks | 0x000100;
    }


    //
    // For secondary side the PWM is not centered around zero or period
    // hence multiply by 2 (<<1) for period*duty
    //
    CLLLC_pwmDutyASec_ticks = (uint32_t)((float32_t)CLLLC_pwmPeriod_ticks *
                                      (float32_t)
                                      (fabsf(CLLLC_pwmDutySec_pu))) << 1;

    //
    // for secondary side B ticks = period - duty_a
    //
    CLLLC_pwmDutyBSec_ticks = (CLLLC_pwmPeriod_ticks) -
                             CLLLC_pwmDutyASec_ticks;

    //
    // first the phase shift in pu is converter to ns
    // this is done for better debug and user friendliness
    //
    CLLLC_pwmPhaseShiftPrimLegs_ns = CLLLC_pwmPhaseShiftPrimLegs_pu *
          ((float32_t)1.0 / CLLLC_pwmFrequency_Hz) *
          (1 / ONE_NANO_SEC);

    //
    // next this ns is simply converted to ticks
    //
    CLLLC_pwmPhaseShiftPrimLegs_ticks =
          (int32_t)((float32_t)CLLLC_pwmPhaseShiftPrimLegs_ns *
                     CLLLC_PWMSYSCLOCK_FREQ_HZ * ONE_NANO_SEC *
                     TWO_RAISED_TO_THE_POWER_SIXTEEN) -
           ((int32_t)2 << 16);

    //
    // due to the delay line implementation depending on whether it is
    // a phase delay or an advance we need to adjust the
    // HR phase shift ticks calculations
    //
    if(CLLLC_pwmPhaseShiftPrimLegs_ticks >= 0)
    {
      CLLLC_pwmPhaseShiftPrimLegs_countDirection = EPWM_COUNT_MODE_DOWN_AFTER_SYNC;

      //
      // CLLLC_pwmPhaseShiftPrimLegs_ticks has the correct value already
      //
    }
    else
    {
      CLLLC_pwmPhaseShiftPrimLegs_countDirection =  EPWM_COUNT_MODE_UP_AFTER_SYNC;
      CLLLC_pwmPhaseShiftPrimLegs_ticks = CLLLC_pwmPhaseShiftPrimLegs_ticks * -1;

      CLLLC_pwmPhaseShiftPrimLegs_HiResticks =  ((uint16_t) 0xFF - ((uint16_t)
                 (CLLLC_pwmPhaseShiftPrimLegs_ticks & 0x0000FFFF) >> 8));

      CLLLC_pwmPhaseShiftPrimLegs_ticks = ((CLLLC_pwmPhaseShiftPrimLegs_ticks & 0xFFFF0000) + 0x10000) +
              (CLLLC_pwmPhaseShiftPrimLegs_HiResticks << 8);
    }

    //
    // Note the actual delay seen may be 10ns different due to floating
    // point rounding
    // phaseShift = (TBPRD/2)-phase_shift_ns_ticks (per the PWM setup)
    // +2<<16 is added to accommodate for PWM sync delays on the chip
    //
    CLLLC_pwmPhaseShiftPrimSec_ticks =
        ((int32_t)(CLLLC_pwmPeriod_ticks >> 1) -
         (int32_t)((float32_t)CLLLC_pwmPhaseShiftPrimSec_ns *
                   CLLLC_PWMSYSCLOCK_FREQ_HZ * ONE_NANO_SEC *
                   TWO_RAISED_TO_THE_POWER_SIXTEEN) +
         ((int32_t)2 << 16));

    CLLLC_pwmPhaseShiftPrimSec_ticks =  CLLLC_pwmPhaseShiftPrimSec_ticks -
            CLLLC_pwmPhaseShiftPrimLegs_ticks;

    //
    // remove the hi-res part for the prim-sec shift
    //
    CLLLC_pwmPhaseShiftPrimSec_ticks = CLLLC_pwmPhaseShiftPrimSec_ticks &
                                    0xFFFF0000;

#if CLLLC_GLOBAL_LOAD_ENABLED == TRUE
        // if global load is working, writes to register can be done here
        HWREG(CLLLC_PRIM_LEG1_PWM_BASE + HRPWM_O_TBPRDHR) = CLLLC_pwmPeriod_ticks;
        HWREG(CLLLC_PRIM_LEG1_PWM_BASE + HRPWM_O_CMPA) = CLLLC_pwmDutyAPrim_ticks;
        HWREG(CLLLC_PRIM_LEG1_PWM_BASE + HRPWM_O_CMPB) = CLLLC_pwmDutyBPrim_ticks;

        HWREG(CLLLC_SEC_LEG1_PWM_BASE + HRPWM_O_CMPA) = CLLLC_pwmDutyASec_ticks;
        HWREG(CLLLC_SEC_LEG1_PWM_BASE + HRPWM_O_CMPB) = CLLLC_pwmDutyBSec_ticks;
#endif

}


#pragma FUNC_ALWAYS_INLINE(CLLLC_calculatePWMDutyPeriodPhaseShiftTicks_primToSecPowerFlow)
static inline void CLLLC_calculatePWMDutyPeriodPhaseShiftTicks_primToSecPowerFlow(void)
{
    uint32_t temp = 0;

    //
    //Debug parameter: uncomment primPhasePrev_ticks to monitor previous PRIM phase ticks
    //
    //uint32_t primPhasePrev_ticks = 0;

    //primPhasePrev_ticks = CLLLC_pwmPhaseShiftPrimLegs_ticks;

    //
    // compute the freq that the period value corresponds to
    //
    CLLLC_pwmFrequency_Hz = (CLLLC_PWMSYSCLOCK_FREQ_HZ /
                                ( CLLLC_pwmPeriod_pu  *
                                 CLLLC_pwmPeriodMax_ticks));

    CLLLC_pwmDutyPrim_pu = CLLLC_pwmDutyPrimRef_pu;
    CLLLC_pwmPhaseShiftPrimSec_ns = CLLLC_pwmPhaseShiftPrimSecRef_ns;
    CLLLC_pwmPhaseShiftPrimLegs_pu = CLLLC_pwmPhaseShiftPrimLegsRef_pu;

    //
    // Calculate duty for SRs based on four components, clamp at 0
    // 1. Initial duty before any adjustments, 45%
    // 2. CLLLC_pwmDutySecAdjust_pu is a manual adjustment to
    //     the initial duty for tuning purposes
    // 3. Subtract pu phase shift between primary and secondary
    // 4. Subtract pu phase shift between primary legs
    //
    CLLLC_pwmDutySec_pu = (0.45f + CLLLC_pwmDutySecAdjust_pu)
                        - (CLLLC_pwmPhaseShiftPrimSec_ns * ONE_NANO_SEC * CLLLC_pwmFrequency_Hz)
                        - CLLLC_pwmPhaseShiftPrimLegs_pu;
    if(CLLLC_pwmDutySec_pu < 0)
    {
        CLLLC_pwmDutySec_pu = 0;
    }

    //
    // First calculate the hi-res ticks for the PWM
    // for this multiply by 2^16 , and divide by 1 (using left shift)
    // as the PWM is up down count mode
    //
    temp = ((uint32_t)(((float32_t)( CLLLC_pwmPeriod_pu  *
                                   CLLLC_pwmPeriodMax_ticks) *
                       (float32_t)TWO_RAISED_TO_THE_POWER_SIXTEEN)))>> 1;

    //
    // next zero the lower 8 bits, as they are not part of TBPRDHR register
    //
    CLLLC_pwmPeriod_ticks = temp & 0xFFFFFF00;

    #if CLLLC_ISR1_RUNNING_ON == CLA_CORE
        CLLLC_pwmISRTrig_ticks = (temp >> 16) - 20;
    #else
        CLLLC_pwmISRTrig_ticks = (temp >> 16) - 27;
    #endif


    if(CLLLC_pwmPhaseShiftPrimLegsRef_pu == 0)
    {
        CLLLC_pwmPhaseShiftPrimLegs_ticks = 0x20000;
        CLLLC_pwmPhaseShiftPrimLegs_countDirection = EPWM_COUNT_MODE_UP_AFTER_SYNC;
    }
    else
    {
        //
        // first the phase shift in pu is converter to ns
        // this is done for better debug and user friendliness
        //
        CLLLC_pwmPhaseShiftPrimLegs_ns = CLLLC_pwmPhaseShiftPrimLegs_pu *
              ((float32_t)1.0 / CLLLC_pwmFrequency_Hz) *
              (1 / ONE_NANO_SEC);

        //
        // next this ns is simply converted to ticks
        //
        CLLLC_pwmPhaseShiftPrimLegs_ticks =
              (int32_t)((float32_t)CLLLC_pwmPhaseShiftPrimLegs_ns *
                         CLLLC_PWMSYSCLOCK_FREQ_HZ * ONE_NANO_SEC *
                         TWO_RAISED_TO_THE_POWER_SIXTEEN) -
               ((int32_t)2 << 16);

        //
        // due to the delay line implementation depending on whether it is
        // a phase delay or an advance we need to adjust the
        // HR phase shift ticks calculations
        //
        if(CLLLC_pwmPhaseShiftPrimLegs_ticks >= 0)
        {
          CLLLC_pwmPhaseShiftPrimLegs_countDirection = EPWM_COUNT_MODE_DOWN_AFTER_SYNC;

          //
          // CLLLC_pwmPhaseShiftPrimLegs_ticks has the correct value already
          //
        }
        else
        {
          CLLLC_pwmPhaseShiftPrimLegs_countDirection =  EPWM_COUNT_MODE_UP_AFTER_SYNC;
          CLLLC_pwmPhaseShiftPrimLegs_ticks = CLLLC_pwmPhaseShiftPrimLegs_ticks * -1;

          CLLLC_pwmPhaseShiftPrimLegs_HiResticks =  ((uint16_t) 0xFF - ((uint16_t)
                     (CLLLC_pwmPhaseShiftPrimLegs_ticks & 0x0000FFFF) >> 8));

          CLLLC_pwmPhaseShiftPrimLegs_ticks = ((CLLLC_pwmPhaseShiftPrimLegs_ticks & 0xFFFF0000) + 0x10000) +
                  (CLLLC_pwmPhaseShiftPrimLegs_HiResticks << 8);
        }
    }

    //
    // Note the actual delay seen may be 10ns different due to floating
    // point rounding
    // phaseShift = (TBPRD/2)-phase_shift_ns_ticks (per the PWM setup)
    // +2<<16 is added to accommodate for PWM sync delays on the chip
    //
    CLLLC_pwmPhaseShiftPrimSec_ticks =
            ((int32_t)(CLLLC_pwmPeriod_ticks >> 1) -
             (int32_t)((float32_t)CLLLC_pwmPhaseShiftPrimSec_ns *
                       CLLLC_PWMSYSCLOCK_FREQ_HZ * ONE_NANO_SEC *
                       TWO_RAISED_TO_THE_POWER_SIXTEEN) +
             ((int32_t)2 << 16));

    CLLLC_pwmPhaseShiftPrimSec_ticks = CLLLC_pwmPhaseShiftPrimSec_ticks -
              CLLLC_pwmPhaseShiftPrimLegs_ticks;

    if(CLLLC_pwmPhaseShiftPrimSec_ticks >= 0)
    {
        CLLLC_pwmPhaseShiftPrimSec_countDirection = EPWM_COUNT_MODE_UP_AFTER_SYNC;
    }
    else
    {
        CLLLC_pwmPhaseShiftPrimSec_countDirection = EPWM_COUNT_MODE_DOWN_AFTER_SYNC;
        CLLLC_pwmPhaseShiftPrimSec_ticks = -CLLLC_pwmPhaseShiftPrimSec_ticks;
    }

    //
    // remove the hi-res part for the prim-sec shift
    //
    CLLLC_pwmPhaseShiftPrimSec_ticks = CLLLC_pwmPhaseShiftPrimSec_ticks &
                                        0xFFFF0000;


    //
    // for hi-res the duty needs to set around period hence calculate
    // duty ticks as (period *(1-duty))
    //
    CLLLC_pwmDutyAPrim_ticks = (uint32_t)((float32_t)CLLLC_pwmPeriod_ticks *
                                         (float32_t)
                                         (1 - fabsf(CLLLC_pwmDutyPrim_pu)));

    //
    // the below is to get around the errata in HRPWM
    //
    if((CLLLC_pwmDutyAPrim_ticks & 0x00FF00) == 0)
    {
        CLLLC_pwmDutyAPrim_ticks = CLLLC_pwmDutyAPrim_ticks | 0x000100;
    }

#if CLLLC_TRANSFORMER_POLARITY == CLLLC_POSTIVE_POLARITY

    //
    //The following code should be used when the transformer polarity matches the schematic.
    //

    //
    // For secondary side the PWM is not centered around zero or period
    // hence multiply by 2 (<<1) for period*duty
    //
    CLLLC_pwmDutyASec_ticks = (uint32_t)((float32_t)CLLLC_pwmPeriod_ticks *
                                      (float32_t)
                                      (fabsf(CLLLC_pwmDutySec_pu))) << 1;

    //
    // for secondary side B ticks = period - duty_a
    //
    CLLLC_pwmDutyBSec_ticks = (CLLLC_pwmPeriod_ticks) -
                             CLLLC_pwmDutyASec_ticks;
#else

    //
    //The following code should be used when the transformer polarity does not match the schematic.
    //

    // For secondary side the PWM is not centered around zero or period
    // hence multiply by 2 (<<1) for period*duty
    //
    CLLLC_pwmDutyBSec_ticks = (uint32_t)((float32_t)CLLLC_pwmPeriod_ticks *
                                      (float32_t)
                                      (fabsf(CLLLC_pwmDutySec_pu))) << 1;

    //
    // for secondary side B ticks = period - duty_a
    //
    CLLLC_pwmDutyASec_ticks = (CLLLC_pwmPeriod_ticks) -
                             CLLLC_pwmDutyBSec_ticks;
#endif
    if(CLLLC_ModulationMode.CLLLC_ModulationMode_Enum == phaseMode)
    {
       //
       // As this is HRPE = 0 mode, zero out the TBPRDHR values
       //
       CLLLC_pwmPeriod_ticks = CLLLC_pwmPeriod_ticks & 0xFFFF0000;
    }

#if CLLLC_GLOBAL_LOAD_ENABLED == TRUE
        //
        // if global load is working, writes to register can be done here
        //
        HWREG(CLLLC_PRIM_LEG1_PWM_BASE + HRPWM_O_TBPRDHR) = CLLLC_pwmPeriod_ticks;
        HWREG(CLLLC_PRIM_LEG1_PWM_BASE + HRPWM_O_CMPA) = CLLLC_pwmDutyAPrim_ticks;
        HWREG(CLLLC_PRIM_LEG1_PWM_BASE + HRPWM_O_CMPB) = CLLLC_pwmDutyBPrim_ticks;

        HWREG(CLLLC_SEC_LEG1_PWM_BASE + HRPWM_O_CMPA) = CLLLC_pwmDutyASec_ticks;
        HWREG(CLLLC_SEC_LEG1_PWM_BASE + HRPWM_O_CMPB) = CLLLC_pwmDutyBSec_ticks;
#endif


}
#pragma FUNC_ALWAYS_INLINE(CLLLC_calculatePWMDutyPeriodPhaseShiftTicks_primToSecPowerFlow_optimized)
static inline void CLLLC_calculatePWMDutyPeriodPhaseShiftTicks_primToSecPowerFlow_optimized(void)
{
    uint32_t temp;

    //
    // First calculate the hi-res ticks for the PWM
    // for this multiply by 2^16 , and divide by 1 (using left shift)
    // as the PWM is up down count mode
    //
    temp = ((uint32_t)(((float32_t)( CLLLC_pwmPeriod_pu  *
                                   CLLLC_pwmPeriodMax_ticks) *
                       (float32_t)TWO_RAISED_TO_THE_POWER_SIXTEEN)))>> 1;

    //
    // next zero the lower 8 bits, as they are not part of TBPRDHR register
    //
    CLLLC_pwmPeriod_ticks = temp & 0xFFFFFF00;

    #if CLLLC_ISR1_RUNNING_ON == CLA_CORE
        CLLLC_pwmISRTrig_ticks = (temp >> 16) - 20;
    #else
        CLLLC_pwmISRTrig_ticks = (temp >> 16) - 27;
    #endif

    //
    // For hi-res the duty needs to set around period hence calculate
    // duty ticks as (period *(1-duty))
    //
    CLLLC_pwmDutyAPrim_ticks = CLLLC_pwmPeriod_ticks >> 1;

    CLLLC_pwmDutyBPrim_ticks = CLLLC_pwmDutyAPrim_ticks;

    //
    // For secondary side the PWM is not centered around zero or period
    // hence multiply by 2 (<<1) for period*duty
    //
    CLLLC_pwmDutyASec_ticks = CLLLC_pwmPeriod_ticks - 10;

    //
    // for secondary side B ticks = period - duty_a
    //
    CLLLC_pwmDutyBSec_ticks = (CLLLC_pwmPeriod_ticks) -
                             CLLLC_pwmDutyASec_ticks;


    //
    // first the phase shift in pu is converter to ns
    // this is done for better debug and user friendliness
    //
    CLLLC_pwmPhaseShiftPrimLegs_ns = CLLLC_pwmPhaseShiftPrimLegs_pu *
          ((float32_t)1.0 / CLLLC_pwmFrequency_Hz) *
          (1 / ONE_NANO_SEC);

    //
    // next this ns is simply converted to ticks
    //
    CLLLC_pwmPhaseShiftPrimLegs_ticks =
          (int32_t)((float32_t)CLLLC_pwmPhaseShiftPrimLegs_ns *
                     CLLLC_PWMSYSCLOCK_FREQ_HZ * ONE_NANO_SEC *
                     TWO_RAISED_TO_THE_POWER_SIXTEEN) -
           ((int32_t)2 << 16);

    //
    // due to the delay line implementation depending on whether it is
    // a phase delay or an advance we need to adjust the
    // HR phase shift ticks calculations
    //
    if(CLLLC_pwmPhaseShiftPrimLegs_ticks >= 0)
    {
      CLLLC_pwmPhaseShiftPrimLegs_countDirection = EPWM_COUNT_MODE_DOWN_AFTER_SYNC;

      //
      // CLLLC_pwmPhaseShiftPrimLegs_ticks has the correct value already
      //
    }
    else
    {
      CLLLC_pwmPhaseShiftPrimLegs_countDirection =  EPWM_COUNT_MODE_UP_AFTER_SYNC;
      CLLLC_pwmPhaseShiftPrimLegs_ticks = CLLLC_pwmPhaseShiftPrimLegs_ticks * -1;

      CLLLC_pwmPhaseShiftPrimLegs_HiResticks =  ((uint16_t) 0xFF - ((uint16_t)
                 (CLLLC_pwmPhaseShiftPrimLegs_ticks & 0x0000FFFF)>>8));

      CLLLC_pwmPhaseShiftPrimLegs_ticks = ((CLLLC_pwmPhaseShiftPrimLegs_ticks & 0xFFFF0000) + 0x10000) +
              (CLLLC_pwmPhaseShiftPrimLegs_HiResticks << 8);
    }

    //
    // Note the actual delay seen may be 10ns different due to floating
    // point rounding
    // phaseShift = (TBPRD/2)-phase_shift_ns_ticks (per the PWM setup)
    // +2<<16 is added to accommodate for PWM sync delays on the chip
    //
    CLLLC_pwmPhaseShiftPrimSec_ticks =
            ((int32_t)(CLLLC_pwmPeriod_ticks >> 1) -
             (int32_t)((float32_t)CLLLC_pwmPhaseShiftPrimSec_ns *
                       CLLLC_PWMSYSCLOCK_FREQ_HZ * ONE_NANO_SEC *
                       TWO_RAISED_TO_THE_POWER_SIXTEEN) +
             ((int32_t)2 << 16));

    CLLLC_pwmPhaseShiftPrimSec_ticks =  CLLLC_pwmPhaseShiftPrimSec_ticks -
              CLLLC_pwmPhaseShiftPrimLegs_ticks;

    //
    // remove the hi-res part for the prim-sec shift
    //
    CLLLC_pwmPhaseShiftPrimSec_ticks = CLLLC_pwmPhaseShiftPrimSec_ticks &
                                        0xFFFF0000;

#if CLLLC_GLOBAL_LOAD_ENABLED == TRUE
        // if global load is working, writes to register can be done here
        HWREG(CLLLC_PRIM_LEG1_PWM_BASE + HRPWM_O_TBPRDHR) = CLLLC_pwmPeriod_ticks;
        HWREG(CLLLC_PRIM_LEG1_PWM_BASE + HRPWM_O_CMPA) = CLLLC_pwmDutyAPrim_ticks;
        HWREG(CLLLC_PRIM_LEG1_PWM_BASE + HRPWM_O_CMPB) = CLLLC_pwmDutyBPrim_ticks;

        HWREG(CLLLC_SEC_LEG1_PWM_BASE + HRPWM_O_CMPA) = CLLLC_pwmDutyASec_ticks;
        HWREG(CLLLC_SEC_LEG1_PWM_BASE + HRPWM_O_CMPB) = CLLLC_pwmDutyBSec_ticks;
#endif

}

#pragma FUNC_ALWAYS_INLINE(CLLLC_calculatePWMDutyPeriodPhaseShiftTicks_secToPrimPowerFlow)
static inline void CLLLC_calculatePWMDutyPeriodPhaseShiftTicks_secToPrimPowerFlow(void)
{
    uint32_t temp;

    //
    // First calculate the hi-res ticks for the PWM
    // for this multiply by 2^16 , and divide by 1 (using left shift)
    // as the PWM is up down count mode
    //
    temp = ((uint32_t)(((float32_t)(CLLLC_pwmPeriodSlewed_pu *
                                   CLLLC_pwmPeriodMax_ticks) *
                       (float32_t)TWO_RAISED_TO_THE_POWER_SIXTEEN)))>> 1;

    //
    // next zero the lower 8 bits, as they are not part of TBPRDHR register
    //
    CLLLC_pwmPeriod_ticks = temp & 0xFFFFFF00;

    //
    // for hi-res the duty needs to set around period hence calculate
    // duty ticks as (period *(1-duty))
    //
    CLLLC_pwmDutyASec_ticks = (uint32_t)((float32_t)CLLLC_pwmPeriod_ticks *
                                         (float32_t)
                                         (1 - fabsf(CLLLC_pwmDutySec_pu)));

    CLLLC_pwmDutyBSec_ticks = CLLLC_pwmDutyASec_ticks;

    //
    // for prim side, dutyA = period * duty_pu * 2.0 (<<1) because the duty is
    // not centered around zero or period
    //
    CLLLC_pwmDutyAPrim_ticks = (uint32_t)((float32_t)CLLLC_pwmPeriod_ticks *
                                      (float32_t)
                                      (fabsf(CLLLC_pwmDutyPrim_pu))) << 1;

    //
    // dutyB = period - dutyA
    //
    CLLLC_pwmDutyBPrim_ticks = (CLLLC_pwmPeriod_ticks) -
                             CLLLC_pwmDutyAPrim_ticks;

    //
    // the below is to get around the errata in HRPWM
    //
    if((CLLLC_pwmDutyASec_ticks & 0x00FF00) == 0)
    {
        CLLLC_pwmDutyASec_ticks = CLLLC_pwmDutyASec_ticks | 0x000100;
    }

    //
    // Note the actual delay seen may be 10ns different due to floating
    // point rounding
    // phaseShift = (TBPRD/2)-phase_shift_ns_ticks (per the PWM setup)
    // +2<<16 is added to accommodate for PWM sync delays on the chip
    //
    CLLLC_pwmPhaseShiftPrimSec_ticks =
            ((int32_t)(CLLLC_pwmPeriod_ticks >> 1) +
             (int32_t)((float32_t)CLLLC_pwmPhaseShiftPrimSec_ns *
                       CLLLC_PWMSYSCLOCK_FREQ_HZ * ONE_NANO_SEC *
                       TWO_RAISED_TO_THE_POWER_SIXTEEN) +
             ((int32_t)2 << 16));


    CLLLC_pwmPhaseShiftPrimSec_ticks = CLLLC_pwmPhaseShiftPrimSec_ticks + CLLLC_pwmPhaseShiftPrimLegs_ticks;

}


#pragma FUNC_ALWAYS_INLINE(CLLLC_calculatePWMDeadBandPrimTicks)
static inline void CLLLC_calculatePWMDeadBandPrimTicks(void)
{
    uint32_t ticks;

    //
    // as we use double clock for the deadband there is a multiple by 2,
    // red_ticks= red_ns*pwm_clk_hz*one_ns*2^16
    // 2^16 multiply is (because of high res)
    //
    ticks = ((uint32_t)(CLLLC_pwmDeadBandREDPrimRef_ns *
                        (float32_t)TWO_RAISED_TO_THE_POWER_SIXTEEN *
                  ((float32_t)ONE_NANO_SEC) * CLLLC_PWMSYSCLOCK_FREQ_HZ * 2.0f));
    CLLLC_pwmDeadBandREDPrim_ticks = ( ticks & 0xFFFFFE00);

    ticks = ((uint32_t)(CLLLC_pwmDeadBandFEDPrimRef_ns *
                        (float32_t)TWO_RAISED_TO_THE_POWER_SIXTEEN *
                  ((float32_t)ONE_NANO_SEC) * CLLLC_PWMSYSCLOCK_FREQ_HZ * 2.0f));
    CLLLC_pwmDeadBandFEDPrim_ticks = ( ticks & 0xFFFFFE00);

}

#pragma FUNC_ALWAYS_INLINE(EPWM_setCounterCompareValue)
#pragma FUNC_ALWAYS_INLINE(EPWM_enablePhaseShiftLoad)
#pragma FUNC_ALWAYS_INLINE(CLLLC_runISR1)
static inline void CLLLC_runISR1(void)
{
#if CLLLC_GLOBAL_LOAD_ENABLED == FALSE
    CLLLC_HAL_updatePWMDutyPeriodPhaseShift(CLLLC_pwmPeriod_ticks,
                      CLLLC_pwmDutyAPrim_ticks,
                      CLLLC_pwmDutyBPrim_ticks,
                      CLLLC_pwmDutyASec_ticks,
                      CLLLC_pwmDutyBSec_ticks,
                      CLLLC_pwmPhaseShiftPrimSec_ticks,
                      CLLLC_pwmPhaseShiftPrimLegs_ticks,
                      CLLLC_pwmPhaseShiftPrimLegs_countDirection,
                      CLLLC_pwmPhaseShiftPrimSec_countDirection);

#else
    EALLOW;
//    HWREG(CLLLC_PRIM_LEG1_PWM_BASE + HRPWM_O_CMPA) = CLLLC_pwmDutyAPrim_ticks;
//    HWREG(CLLLC_PRIM_LEG1_PWM_BASE + HRPWM_O_CMPB) = CLLLC_pwmDutyAPrim_ticks;
    HWREG(CLLLC_SEC_LEG1_PWM_BASE + EPWM_O_TBPHS) =  CLLLC_pwmPhaseShiftPrimSec_ticks;
    HWREG(CLLLC_SEC_LEG2_PWM_BASE + EPWM_O_TBPHS) =  CLLLC_pwmPhaseShiftPrimSec_ticks;
    HWREG(CLLLC_PRIM_LEG1_PWM_BASE + EPWM_O_GLDCTL2) =  1;
  //  EPWM_setGlobalLoadOneShotLatch(CLLLC_PRIM_LEG1_PWM_BASE);
    EDIS;
#endif

    //
    // Now set the ISR1 trigger such that it does not trigger again; CMPC > TBPRD
    //
    HWREGH(CLLLC_ISR1_PERIPHERAL_TRIG_BASE + EPWM_O_CMPA + EPWM_COUNTER_COMPARE_C) = 0xFFFF;


    //
    // Clear ISR1 Peripheral Interrupt flag
    //
    #pragma diag_suppress = 173
    HWREGH(CLLLC_ISR1_PERIPHERAL_TRIG_BASE + EPWM_O_ETCLR) = 1;
    #pragma diag_warning = 173

  //  CLLLC_HAL_clearISR1PeripheralInterruptFlag();

}


//
// This may no longer be needed
//
//#pragma FUNC_ALWAYS_INLINE(CLLLC_runISR1_secondTime)
//static inline void CLLLC_runISR1_secondTime(void)
//{
//   // EPWM_disablePhaseShiftLoad(CLLLC_SEC_LEG1_PWM_BASE);
//   // EPWM_disablePhaseShiftLoad(CLLLC_SEC_LEG2_PWM_BASE);
//    CLLLC_HAL_setupISR1Trigger(CLLLC_MIN_PWM_SWITCHING_FREQUENCY_HZ * 0.3);
//    CLLLC_HAL_clearISR1PeripheralInterruptFlag();
//}

#pragma FUNC_ALWAYS_INLINE(CLLLC_runISR1_phaseShift)
static inline void CLLLC_runISR1_phaseShift(void)
{
#if CLLLC_GLOBAL_LOAD_ENABLED == FALSE
    CLLLC_HAL_updatePWMDutyPeriodPhaseShift_PhaseShiftMode(CLLLC_pwmPeriod_ticks,
                                                           CLLLC_pwmDutyAPrim_ticks,
                                                           CLLLC_pwmDutyASec_ticks,
                                                           CLLLC_pwmDutyBSec_ticks,
                                                           CLLLC_pwmPhaseShiftPrimSec_ticks,
                                                           CLLLC_pwmPhaseShiftPrimLegs_ticks,
                                                           CLLLC_pwmPhaseShiftPrimLegs_countDirection);
#else
    HWREG(CLLLC_PRIM_LEG1_PWM_BASE + EPWM_O_TBPHS) =  CLLLC_pwmPhaseShiftPrimLegs_ticks;
    HWREG(CLLLC_SEC_LEG1_PWM_BASE + EPWM_O_TBPHS) =  CLLLC_pwmPhaseShiftPrimSec_ticks;
    HWREG(CLLLC_SEC_LEG2_PWM_BASE + EPWM_O_TBPHS) =  CLLLC_pwmPhaseShiftPrimSec_ticks;
    EPWM_setCountModeAfterSync(CLLLC_PRIM_LEG2_PWM_BASE,
                            (EPWM_SyncCountMode)CLLLC_pwmPhaseShiftPrimLegs_countDirection);
    EPWM_setGlobalLoadOneShotLatch(CLLLC_PRIM_LEG1_PWM_BASE);
#endif

    EPWM_enablePhaseShiftLoad(CLLLC_PRIM_LEG2_PWM_BASE);

    //
    // setup trigger such that ISR1 will never occur
    //
    CLLLC_HAL_setupISR1Trigger(CLLLC_MIN_PWM_SWITCHING_FREQUENCY_HZ * 0.3);

    CLLLC_HAL_clearISR1PeripheralInterruptFlag();
}

#pragma FUNC_ALWAYS_INLINE(CLLLC_clearPWMTrip)
static inline void CLLLC_clearPWMTrip(void)
{
    if(CLLLC_clearTrip == 1)
    {
        //
        // Clear trip on PWMs
        //
        CLLLC_HAL_clearPWMTripFlags(CLLLC_PRIM_LEG1_PWM_BASE);
        CLLLC_HAL_clearPWMTripFlags(CLLLC_PRIM_LEG2_PWM_BASE);
        #if(CLLLC_ASR_ENABLE == 1)
                CLLLC_HAL_clearPWMTripFlags(CLLLC_SEC_LEG1_PWM_BASE);
                CLLLC_HAL_clearPWMTripFlags(CLLLC_SEC_LEG2_PWM_BASE);
        #endif

        //
        // In battery emulated test the loop needs to be closed very fast
        // hence the closeGiLoop is also turned to be 1 here
        //
        #if CLLLC_TEST_SETUP == CLLLC_TEST_SETUP_EMULATED_BATTERY
            CLLLC_closeGiLoop = 1;
        #endif


        //
        // Update state variables
        //
        CLLLC_tripFlag.CLLLC_TripFlag_Enum = noTrip;
        CLLLC_clearTrip = 0;
    }
}

#pragma FUNC_ALWAYS_INLINE(CLLLC_modeDetect)
static inline void CLLLC_modeDetect(void)
{
    //
    // Phase Shift PWM driver if CLLLC_pwmPhaseShiftPrimLegsRef_pu is not zero
    //
    if(CLLLC_pwmPhaseShiftPrimLegsRef_pu != 0.0f)
    {
      //
      // If in phase shift mode disable high resolution period, and use phase control
      //
//      HRPWM_setMEPControlMode(CLLLC_PRIM_LEG1_PWM_BASE, HRPWM_CHANNEL_A, HRPWM_MEP_PHASE_CTRL);
//      HRPWM_setMEPControlMode(CLLLC_PRIM_LEG2_PWM_BASE, HRPWM_CHANNEL_A, HRPWM_MEP_PHASE_CTRL);
//      HRPWM_setMEPControlMode(CLLLC_SEC_LEG1_PWM_BASE, HRPWM_CHANNEL_A, HRPWM_MEP_PHASE_CTRL);
//      HRPWM_setMEPControlMode(CLLLC_SEC_LEG2_PWM_BASE, HRPWM_CHANNEL_A, HRPWM_MEP_PHASE_CTRL);

       //
       // Inlined function, enable high resolution Period mode, and use phase control can use function call with code optimization 4+
       //

        HWREGH(CLLLC_PRIM_LEG1_PWM_BASE + HRPWM_O_HRCNFG) =
                ((HWREGH(CLLLC_PRIM_LEG1_PWM_BASE + HRPWM_O_HRCNFG) & ~(0x1U << ((uint16_t)HRPWM_CHANNEL_A + 2U))) |
                        ((uint16_t)HRPWM_MEP_PHASE_CTRL << ((uint16_t)HRPWM_CHANNEL_A + 2U)));
        HWREGH(CLLLC_PRIM_LEG2_PWM_BASE + HRPWM_O_HRCNFG) =
                ((HWREGH(CLLLC_PRIM_LEG2_PWM_BASE + HRPWM_O_HRCNFG) & ~(0x1U << ((uint16_t)HRPWM_CHANNEL_A + 2U))) |
                        ((uint16_t)HRPWM_MEP_PHASE_CTRL << ((uint16_t)HRPWM_CHANNEL_A + 2U)));
        HWREGH(CLLLC_SEC_LEG1_PWM_BASE + HRPWM_O_HRCNFG) =
                ((HWREGH(CLLLC_SEC_LEG1_PWM_BASE + HRPWM_O_HRCNFG) & ~(0x1U << ((uint16_t)HRPWM_CHANNEL_A + 2U))) |
                        ((uint16_t)HRPWM_MEP_PHASE_CTRL << ((uint16_t)HRPWM_CHANNEL_A + 2U)));
        HWREGH(CLLLC_SEC_LEG2_PWM_BASE + HRPWM_O_HRCNFG) =
                ((HWREGH(CLLLC_SEC_LEG2_PWM_BASE + HRPWM_O_HRCNFG) & ~(0x1U << ((uint16_t)HRPWM_CHANNEL_A + 2U))) |
                        ((uint16_t)HRPWM_MEP_PHASE_CTRL << ((uint16_t)HRPWM_CHANNEL_A + 2U)));

      EPWM_enablePhaseShiftLoad(CLLLC_PRIM_LEG2_PWM_BASE);

      //
      // Set the modulation mode to be phase mode
      //
      CLLLC_ModulationMode.CLLLC_ModulationMode_Enum = phaseMode;

    }
    //
    // Frequency Mode PWM driver
    // If phase shift prim legs is zero, then it is freq mode
    //
    else
    {
        //
        // Below code is used to trigger a one time sync for prim legs before
        // fully transitioning to freq mode
        //
        if(CLLLC_ModulationMode.CLLLC_ModulationMode_Enum == phaseMode)
        {
           //
           // Clear TRREM to ensure synchronization before entering freq. mode
           //
           EALLOW;
           HWREGH(CLLLC_PRIM_LEG2_PWM_BASE + EPWM_O_TRREM) =  HWREGH(CLLLC_PRIM_LEG1_PWM_BASE + EPWM_O_TRREM);
           EDIS;

           //
           // Now set the modulation mode to be freq mode
           // thus this section will not be executed again, unless one goes to phase mode
           //
           CLLLC_ModulationMode.CLLLC_ModulationMode_Enum = freqMode;

           CLLLC_modeChangeFlag = 1;
        }
        else
        {
           //
           // This is the freq modulation mode
           //
           CLLLC_ModulationMode.CLLLC_ModulationMode_Enum = freqMode;

           //
           // Enable high resolution frequency mode
           //
//           HRPWM_setMEPControlMode(CLLLC_PRIM_LEG1_PWM_BASE, HRPWM_CHANNEL_A, HRPWM_MEP_DUTY_PERIOD_CTRL);
//           HRPWM_setMEPControlMode(CLLLC_PRIM_LEG2_PWM_BASE, HRPWM_CHANNEL_A, HRPWM_MEP_DUTY_PERIOD_CTRL);
//           HRPWM_setMEPControlMode(CLLLC_SEC_LEG1_PWM_BASE, HRPWM_CHANNEL_A, HRPWM_MEP_DUTY_PERIOD_CTRL);
//           HRPWM_setMEPControlMode(CLLLC_SEC_LEG2_PWM_BASE, HRPWM_CHANNEL_A, HRPWM_MEP_DUTY_PERIOD_CTRL);

           //
           // Inlined function enable high resolution frequency mode
           //
           EALLOW;

           HWREGH(CLLLC_PRIM_LEG1_PWM_BASE + HRPWM_O_HRCNFG) =
                         ((HWREGH(CLLLC_PRIM_LEG1_PWM_BASE + HRPWM_O_HRCNFG) & ~(0x1U << ((uint16_t)HRPWM_CHANNEL_A + 2U))) |
                           ((uint16_t)HRPWM_MEP_DUTY_PERIOD_CTRL << ((uint16_t)HRPWM_CHANNEL_A + 2U)));
           HWREGH(CLLLC_PRIM_LEG2_PWM_BASE + HRPWM_O_HRCNFG) =
                         ((HWREGH(CLLLC_PRIM_LEG2_PWM_BASE + HRPWM_O_HRCNFG) & ~(0x1U << ((uint16_t)HRPWM_CHANNEL_A + 2U))) |
                           ((uint16_t)HRPWM_MEP_DUTY_PERIOD_CTRL << ((uint16_t)HRPWM_CHANNEL_A + 2U)));
           HWREGH(CLLLC_SEC_LEG1_PWM_BASE + HRPWM_O_HRCNFG) =
                         ((HWREGH(CLLLC_SEC_LEG1_PWM_BASE + HRPWM_O_HRCNFG) & ~(0x1U << ((uint16_t)HRPWM_CHANNEL_A + 2U))) |
                           ((uint16_t)HRPWM_MEP_DUTY_PERIOD_CTRL << ((uint16_t)HRPWM_CHANNEL_A + 2U)));
           HWREGH(CLLLC_SEC_LEG2_PWM_BASE + HRPWM_O_HRCNFG) =
                         ((HWREGH(CLLLC_SEC_LEG2_PWM_BASE + HRPWM_O_HRCNFG) & ~(0x1U << ((uint16_t)HRPWM_CHANNEL_A + 2U))) |
                           ((uint16_t)HRPWM_MEP_DUTY_PERIOD_CTRL << ((uint16_t)HRPWM_CHANNEL_A + 2U)));

           EDIS;


           //
           // Disable the PRIM LEG2 Sync
           //
           EPWM_disablePhaseShiftLoad(CLLLC_PRIM_LEG2_PWM_BASE);
        }
    }
}

#pragma FUNC_ALWAYS_INLINE(CLLLC_runOpenLoop)
static inline void CLLLC_runOpenLoop(void)
{
    CLLLC_readSensedSignalsPrimToSecPowerFlow();
    CLLLC_clearPWMTrip();
    CLLLC_modeDetect();
    CLLLC_setCommutatorLC(CLLLC_enableLC);

    //
    // If there is a change in the ref command then set the GPIO
    //
    if(CLLLC_pwmPeriod_pu != CLLLC_pwmPeriodRef_pu ||
       CLLLC_pwmDutyPrim_pu != CLLLC_pwmDutyPrimRef_pu ||
       CLLLC_pwmPhaseShiftPrimSec_ns != CLLLC_pwmPhaseShiftPrimSecRef_ns ||
       CLLLC_pwmPhaseShiftPrimLegs_pu != CLLLC_pwmPhaseShiftPrimLegsRef_pu)
    {
        CLLLC_HAL_setFreqStepChange();
    }

    //
    // Write the Ref values to the active values
    //
#if(CLLLC_SFRA_TYPE != CLLLC_SFRA_DISABLED)
    CLLLC_pwmPeriod_pu = CLLLC_SFRA_INJECT(CLLLC_pwmPeriodRef_pu);
#else
    CLLLC_pwmPeriod_pu = CLLLC_pwmPeriodRef_pu;
#endif

    CLLLC_calculatePWMDutyPeriodPhaseShiftTicks_primToSecPowerFlow();

#if(CLLLC_SFRA_TYPE == CLLLC_SFRA_VOLTAGE)
    CLLLC_SFRA_COLLECT(&CLLLC_pwmPeriod_pu, &CLLLC_vSecSensed_pu);
#elif(CLLLC_SFRA_TYPE == CLLLC_SFRA_CURRENT)
    CLLLC_SFRA_COLLECT(&CLLLC_pwmPeriod_pu, &CLLLC_iSecSensed_pu);
#endif

    CLLLC_HAL_setupISR1Trigger(CLLLC_pwmFrequencyPrev_Hz);
    CLLLC_pwmFrequencyPrev_Hz = CLLLC_pwmFrequency_Hz;

    CLLLC_HAL_resetFreqStepChange();


    CLLLC_HAL_clearISR2PeripheralInterruptFlag();
}

#pragma FUNC_ALWAYS_INLINE(CLLLC_runVoltageLoop)
static inline void CLLLC_runVoltageLoop(void)
{
    CLLLC_readSensedSignalsPrimToSecPowerFlow();
    CLLLC_clearPWMTrip();
    CLLLC_modeDetect();
//    CLLLC_setCommutatorLC(CLLLC_enableLC);

    if(CLLLC_closeGvLoop == 1)
    {

        #if CLLLC_SFRA_TYPE == CLLLC_SFRA_VOLTAGE
            CLLLC_gvError = (CLLLC_SFRA_INJECT(CLLLC_vSecRefSlewed_pu) -
                                              CLLLC_vSecSensed_pu);
        #else
            CLLLC_gvError = (CLLLC_vSecRefSlewed_pu - CLLLC_vSecSensed_pu);
        #endif

        CLLLC_gvOut = CLLLC_GV_IMMEDIATE_RUN(&CLLLC_gv,
                                       CLLLC_gvError,
                                       CLLLC_gvPartialComputedValue);

        if(CLLLC_gvOut > CLLLC_GV_OUT_MAX)
        {
            CLLLC_gvOut = CLLLC_GV_OUT_MAX;
        }
        if(CLLLC_gvOut < CLLLC_GV_OUT_MIN)
        {
            CLLLC_gvOut = CLLLC_GV_OUT_MIN;
        }

        CLLLC_gvPartialComputedValue = CLLLC_GV_PRECOMPUTE_RUN(&CLLLC_gv,
                                                                CLLLC_gvError,
                                                                CLLLC_gvOut);

        if(CLLLC_gvOut < CLLLC_pwmPeriodMin_pu)
        {
            //
            // Phase shift compensation and clamping
            //
            CLLLC_pwmPhaseShiftPrimLegsRef_pu = (CLLLC_pwmPeriodMin_pu - CLLLC_gvOut) * CLLLC_PHASE_COMP_SCALING;
            if(CLLLC_pwmPhaseShiftPrimLegsRef_pu > CLLLC_PHASE_COMP_MAX)
            {
                CLLLC_pwmPhaseShiftPrimLegsRef_pu = CLLLC_PHASE_COMP_MAX;
            }

            //
            // Clamp period
            //
            CLLLC_gvOut = CLLLC_pwmPeriodMin_pu;
        }
        else
        {
            CLLLC_pwmPhaseShiftPrimLegsRef_pu = 0;
        }

        CLLLC_pwmPeriod_pu = CLLLC_gvOut;
    }
    else
    {
        CLLLC_gv.d4 = CLLLC_pwmPeriod_pu;
        CLLLC_gv.d5 = CLLLC_pwmPeriod_pu;
        CLLLC_gv.d6 = CLLLC_pwmPeriod_pu;
        CLLLC_gv.d7 = CLLLC_pwmPeriod_pu;

        CLLLC_gvError = (CLLLC_vSecRefSlewed_pu - CLLLC_vSecSensed_pu);
        CLLLC_gv.d0 = CLLLC_gvError;
        CLLLC_gv.d1 = CLLLC_gvError;
        CLLLC_gv.d2 = CLLLC_gvError;
        CLLLC_gv.d3 = CLLLC_gvError;

        CLLLC_gvPartialComputedValue = CLLLC_pwmPeriod_pu;


        CLLLC_pwmPeriod_pu = CLLLC_pwmPeriodRef_pu;


        if(CLLLC_pwmPeriod_pu < CLLLC_pwmPeriodMin_pu)
        {
            CLLLC_pwmPeriod_pu = CLLLC_pwmPeriodMin_pu;
        }
        else if(CLLLC_pwmPeriod_pu > 1.0f)
        {
            CLLLC_pwmPeriod_pu = 1.0f;
        }
    }

    CLLLC_HAL_updateDAC(CLLLC_gvOut);

    CLLLC_calculatePWMDutyPeriodPhaseShiftTicks_primToSecPowerFlow();

#if(CLLLC_SFRA_TYPE == CLLLC_SFRA_VOLTAGE)
    CLLLC_SFRA_COLLECT(&CLLLC_pwmPeriod_pu, &CLLLC_vSecSensed_pu);
#elif(CLLLC_SFRA_TYPE == CLLLC_SFRA_CURRENT)
    CLLLC_SFRA_COLLECT(&CLLLC_pwmPeriod_pu, &CLLLC_iSecSensed_pu);
#endif

    CLLLC_HAL_setupISR1Trigger(CLLLC_pwmFrequencyPrev_Hz);
    CLLLC_pwmFrequencyPrev_Hz = CLLLC_pwmFrequency_Hz;

    CLLLC_HAL_clearISR2PeripheralInterruptFlag();
}

#pragma FUNC_ALWAYS_INLINE(CLLLC_runCurrentLoop)
static inline void CLLLC_runCurrentLoop(void)
{
    CLLLC_readSensedSignalsPrimToSecPowerFlow();
    CLLLC_clearPWMTrip();
    CLLLC_modeDetect();
    CLLLC_setCommutatorLC(CLLLC_enableLC);

    if(CLLLC_closeGiLoop == 1)
    {
        #if CLLLC_SFRA_TYPE == CLLLC_SFRA_CURRENT
            CLLLC_giError = (CLLLC_SFRA_INJECT(CLLLC_iSecRefSlewed_pu) -
                                             CLLLC_iSecSensed_pu);
        #else
            CLLLC_giError = (CLLLC_iSecRefSlewed_pu - CLLLC_iSecSensed_pu);
        #endif

        CLLLC_giOut = CLLLC_GI_IMMEDIATE_RUN(&CLLLC_gi,
                                       CLLLC_giError,
                                       CLLLC_giPartialComputedValue);

        if(CLLLC_giOut > CLLLC_GI_OUT_MAX)
        {
            CLLLC_giOut = CLLLC_GI_OUT_MAX;
        }
        if(CLLLC_giOut < CLLLC_GI_OUT_MIN)
        {
            CLLLC_giOut = CLLLC_GI_OUT_MIN;
        }

        CLLLC_giPartialComputedValue = CLLLC_GI_PRECOMPUTE_RUN(&CLLLC_gi,
                                                        CLLLC_giError,
                                                        CLLLC_giOut);

        if(CLLLC_giOut < CLLLC_pwmPeriodMin_pu)
        {
            //
            // Phase shift compensation and clamping
            //
            CLLLC_pwmPhaseShiftPrimLegsRef_pu = (CLLLC_pwmPeriodMin_pu - CLLLC_giOut) * CLLLC_PHASE_COMP_SCALING;
            if(CLLLC_pwmPhaseShiftPrimLegsRef_pu > CLLLC_PHASE_COMP_MAX)
            {
                CLLLC_pwmPhaseShiftPrimLegsRef_pu = CLLLC_PHASE_COMP_MAX;
            }

            //
            // Clamp period
            //
            CLLLC_giOut = CLLLC_pwmPeriodMin_pu;
        }
        else
        {
            CLLLC_pwmPhaseShiftPrimLegsRef_pu = 0;
        }

        CLLLC_pwmPeriod_pu = CLLLC_giOut;
    }
    else
    {
        CLLLC_gi.d4 = CLLLC_pwmPeriod_pu;
        CLLLC_gi.d5 = CLLLC_pwmPeriod_pu;
        CLLLC_gi.d6 = CLLLC_pwmPeriod_pu;
        CLLLC_gi.d7 = CLLLC_pwmPeriod_pu;

        CLLLC_giError = (CLLLC_iSecRefSlewed_pu - CLLLC_iSecSensed_pu);
        CLLLC_gi.d0 = CLLLC_giError;
        CLLLC_gi.d1 = CLLLC_giError;
        CLLLC_gi.d2 = CLLLC_giError;
        CLLLC_gi.d3 = CLLLC_giError;

        CLLLC_giPartialComputedValue = CLLLC_pwmPeriod_pu;

        CLLLC_pwmPeriod_pu = CLLLC_pwmPeriodRef_pu;

        if(CLLLC_pwmPeriod_pu < CLLLC_pwmPeriodMin_pu)
        {
            CLLLC_pwmPeriod_pu = CLLLC_pwmPeriodMin_pu;
        }
        else if(CLLLC_pwmPeriod_pu > 1.0f)
        {
            CLLLC_pwmPeriod_pu = 1.0f;
        }
    }



    CLLLC_HAL_updateDAC(CLLLC_giOut);

    CLLLC_calculatePWMDutyPeriodPhaseShiftTicks_primToSecPowerFlow();

#if(CLLLC_SFRA_TYPE == CLLLC_SFRA_VOLTAGE)
    CLLLC_SFRA_COLLECT(&CLLLC_pwmPeriod_pu, &CLLLC_vSecSensed_pu);
#elif(CLLLC_SFRA_TYPE == CLLLC_SFRA_CURRENT)
    CLLLC_SFRA_COLLECT(&CLLLC_pwmPeriod_pu, &CLLLC_iSecSensed_pu);
#endif

    CLLLC_HAL_setupISR1Trigger(CLLLC_pwmFrequencyPrev_Hz);
    CLLLC_pwmFrequencyPrev_Hz = CLLLC_pwmFrequency_Hz;

    CLLLC_HAL_clearISR2PeripheralInterruptFlag();
}

#pragma FUNC_ALWAYS_INLINE(CLLLC_runISR2_primToSecPowerFlow)
static inline void CLLLC_runISR2_primToSecPowerFlow(void)
{
    //
    // Read Current and Voltage Measurements
    //
    CLLLC_readSensedSignalsPrimToSecPowerFlow();

    if(CLLLC_clearTrip == 1)
    {
        CLLLC_HAL_clearPWMTripFlags(CLLLC_PRIM_LEG1_PWM_BASE);
        CLLLC_HAL_clearPWMTripFlags(CLLLC_PRIM_LEG2_PWM_BASE);
        CLLLC_HAL_clearPWMTripFlags(CLLLC_SEC_LEG1_PWM_BASE);
        CLLLC_HAL_clearPWMTripFlags(CLLLC_SEC_LEG2_PWM_BASE);

        #if CLLLC_TEST_SETUP == CLLLC_TEST_SETUP_EMULATED_BATTERY
            CLLLC_closeGiLoop = 1;
        #endif

        CLLLC_clearTrip = 0;
    }

//    if(CLLLC_closeGiLoop == 1)
//    {
//        #if CLLLC_SFRA_TYPE == CLLLC_SFRA_CURRENT
//            CLLLC_giError = (CLLLC_SFRA_INJECT(CLLLC_iSecRefSlewed_pu) -
//                                             CLLLC_iSecSensed_pu);
//        #else
//            CLLLC_giError = (CLLLC_iSecRefSlewed_pu - CLLLC_iSecSensed_pu);
//        #endif
//
//        CLLLC_giOut = CLLLC_GI_IMMEDIATE_RUN(&CLLLC_gi,
//                                       CLLLC_giError,
//                                       CLLLC_giPartialComputedValue);
//
//        if(CLLLC_giOut > CLLLC_GI_OUT_MAX)
//        {
//            CLLLC_giOut = CLLLC_GI_OUT_MAX;
//        }
//        if(CLLLC_giOut < CLLLC_GI_OUT_MIN)
//        {
//            CLLLC_giOut = CLLLC_GI_OUT_MIN;
//        }
//
//        CLLLC_giPartialComputedValue = CLLLC_GI_PRECOMPUTE_RUN(&CLLLC_gi,
//                                                        CLLLC_giError,
//                                                        CLLLC_giOut);
//
//        if(CLLLC_giOut < CLLLC_pwmPeriodMin_pu)
//        {
//            CLLLC_giOut = CLLLC_pwmPeriodMin_pu;
//        }
//
//        CLLLC_pwmPeriod_pu = CLLLC_giOut;
//    }
//    else if(CLLLC_closeGvLoop == 1)
//    {
//
//        #if CLLLC_SFRA_TYPE == CLLLC_SFRA_VOLTAGE
//            CLLLC_gvError = (CLLLC_SFRA_INJECT(CLLLC_vSecRefSlewed_pu) -
//                                              CLLLC_vSecSensed_pu);
//        #else
//            CLLLC_gvError = (CLLLC_vSecRefSlewed_pu - CLLLC_vSecSensed_pu);
//        #endif
//
//        CLLLC_gvOut = CLLLC_GV_IMMEDIATE_RUN(&CLLLC_gv,
//                                       CLLLC_gvError,
//                                       CLLLC_gvPartialComputedValue);
//
//        if(CLLLC_gvOut > CLLLC_GV_OUT_MAX)
//        {
//            CLLLC_gvOut = CLLLC_GV_OUT_MAX;
//        }
//        if(CLLLC_gvOut < CLLLC_GV_OUT_MIN)
//        {
//            CLLLC_gvOut = CLLLC_GV_OUT_MIN;
//        }
//
//        CLLLC_gvPartialComputedValue = CLLLC_GV_PRECOMPUTE_RUN(&CLLLC_gv,
//                                                                CLLLC_gvError,
//                                                                CLLLC_gvOut);
//
//        if(CLLLC_gvOut < CLLLC_pwmPeriodMin_pu)
//        {
//            CLLLC_gvOut = CLLLC_pwmPeriodMin_pu;
//        }
//
//        CLLLC_pwmPeriod_pu = CLLLC_gvOut;
//    }
//    else
//    {
//
//        CLLLC_gi.d4 = CLLLC_pwmPeriod_pu;
//        CLLLC_gi.d5 = CLLLC_pwmPeriod_pu;
//        CLLLC_gi.d6 = CLLLC_pwmPeriod_pu;
//        CLLLC_gi.d7 = CLLLC_pwmPeriod_pu;
//
//        CLLLC_gv.d4 = CLLLC_pwmPeriod_pu;
//        CLLLC_gv.d5 = CLLLC_pwmPeriod_pu;
//        CLLLC_gv.d6 = CLLLC_pwmPeriod_pu;
//        CLLLC_gv.d7 = CLLLC_pwmPeriod_pu;
//
//        CLLLC_giError = (CLLLC_iSecRefSlewed_pu - CLLLC_iSecSensed_pu);
//        CLLLC_gi.d0 = CLLLC_giError;
//        CLLLC_gi.d1 = CLLLC_giError;
//        CLLLC_gi.d2 = CLLLC_giError;
//        CLLLC_gi.d3 = CLLLC_giError;
//
//        CLLLC_giPartialComputedValue = CLLLC_pwmPeriod_pu;
//
//        CLLLC_gvError = (CLLLC_vSecRefSlewed_pu - CLLLC_vSecSensed_pu);
//        CLLLC_gv.d0 = CLLLC_gvError;
//        CLLLC_gv.d1 = CLLLC_gvError;
//        CLLLC_gv.d2 = CLLLC_gvError;
//        CLLLC_gv.d3 = CLLLC_gvError;
//
//        CLLLC_gvPartialComputedValue = CLLLC_pwmPeriod_pu;
//
//        #if CLLLC_INCR_BUILD == CLLLC_OPEN_LOOP_BUILD
//            #if CLLLC_SFRA_TYPE != CLLLC_SFRA_DISABLED
//                CLLLC_pwmPeriod_pu =
//                                CLLLC_SFRA_INJECT(CLLLC_pwmPeriodRef_pu);
//
//            #else
//                CLLLC_pwmPeriod_pu = CLLLC_pwmPeriodRef_pu;
//            #endif
//        #else
//            CLLLC_pwmPeriod_pu = CLLLC_pwmPeriodRef_pu;
//        #endif
//
//        if(CLLLC_pwmPeriod_pu < CLLLC_pwmPeriodMin_pu)
//        {
//            CLLLC_pwmPeriod_pu = CLLLC_pwmPeriodMin_pu;
//        }
//        else if(CLLLC_pwmPeriod_pu > 1.0f)
//        {
//            CLLLC_pwmPeriod_pu = 1.0f;
//        }
//    }

#if CLLLC_SLEW_FREQ_CHANGE == 1
    if(fabsf(CLLLC_pwmPeriod_pu - CLLLC_pwmPeriodSlewed_pu) >
                        CLLLC_MAX_PERIOD_STEP_PU)
    {
        if(CLLLC_pwmPeriod_pu > CLLLC_pwmPeriodSlewed_pu)
        {
            CLLLC_pwmPeriodSlewed_pu = CLLLC_pwmPeriodSlewed_pu +
                                        CLLLC_MAX_PERIOD_STEP_PU;
        }
        else
        {
            CLLLC_pwmPeriodSlewed_pu = CLLLC_pwmPeriodSlewed_pu -
                                        CLLLC_MAX_PERIOD_STEP_PU;
        }
    }
    else
    {
        CLLLC_pwmPeriodSlewed_pu = CLLLC_pwmPeriod_pu;
    }

#else

    if(CLLLC_pwmPeriodSlewed_pu !=  CLLLC_pwmPeriod_pu ||
       CLLLC_pwmDutyPrim_pu != CLLLC_pwmDutyPrimRef_pu ||
       CLLLC_pwmPhaseShiftPrimSec_ns != CLLLC_pwmPhaseShiftPrimSecRef_ns)
    {

        //
        // Write the Ref values to the active values
        //
        CLLLC_pwmPeriodSlewed_pu =  CLLLC_pwmPeriod_pu;
        CLLLC_pwmDutyPrim_pu = CLLLC_pwmDutyPrimRef_pu;
        CLLLC_pwmDutySec_pu = CLLLC_pwmDutySecRef_pu;
        CLLLC_pwmPhaseShiftPrimSec_ns = CLLLC_pwmPhaseShiftPrimSecRef_ns;
        CLLLC_pwmDutySec_pu = CLLLC_pwmDutySecRef_pu;

        CLLLC_pwmFrequency_Hz = (CLLLC_PWMSYSCLOCK_FREQ_HZ /
                                    ( CLLLC_pwmPeriod_pu  *
                                     CLLLC_pwmPeriodMax_ticks));

        CLLLC_calculatePWMDutyPeriodPhaseShiftTicks_primToSecPowerFlow();

        CLLLC_HAL_setupISR1Trigger(CLLLC_pwmFrequencyPrev_Hz);

        CLLLC_pwmFrequencyPrev_Hz = CLLLC_pwmFrequency_Hz;
    }

#endif


    #if CLLLC_SFRA_TYPE == CLLLC_SFRA_CURRENT
        CLLLC_SFRA_COLLECT((float32_t *)&CLLLC_pwmPeriodSlewed_pu,
                     (float32_t *)&CLLLC_iSecSensed_pu);
    #elif CLLLC_SFRA_TYPE == CLLLC_SFRA_VOLTAGE
        CLLLC_SFRA_COLLECT((float32_t *)&CLLLC_pwmPeriodSlewed_pu,
                     (float32_t *)&CLLLC_vSecSensed_pu);
    #else
        //
        //this is the default condition, and also when SFRA is disabled
        //
        #ifndef __TMS320C28XX_CLA__
//        CLLLC_slewSCIcommand++;
//        if(CLLLC_slewSCIcommand > 20)
//        {
//            CLLLC_slewSCIcommand = 0;
//            CLLLC_HAL_sendCommandOverSCI(
//                       CLLLC_commandSentTo_AC_DC.CLLLC_CommandSentTo_AC_DC_Enum,
//                               CLLLC_vPrimRef_Volts);
//        }
        #endif
    #endif





    CLLLC_HAL_clearISR2PeripheralInterruptFlag();
   // CLLLC_HAL_clearISR1PeripheralInterruptFlag();
}

#pragma FUNC_ALWAYS_INLINE(CLLLC_runISR2_secToPrimPowerFlow)
static inline void CLLLC_runISR2_secToPrimPowerFlow(void)
{
    //
    // Read Current and Voltage Measurements
    //
    CLLLC_readSensedSignalsSecToPrimPowerFlow();

    if(CLLLC_clearTrip == 1)
    {
        CLLLC_HAL_clearPWMTripFlags(CLLLC_PRIM_LEG1_PWM_BASE);
        CLLLC_HAL_clearPWMTripFlags(CLLLC_PRIM_LEG2_PWM_BASE);
        CLLLC_HAL_clearPWMTripFlags(CLLLC_SEC_LEG1_PWM_BASE);
        CLLLC_HAL_clearPWMTripFlags(CLLLC_SEC_LEG2_PWM_BASE);

        CLLLC_clearTrip = 0;
    }

//    if(CLLLC_closeGvLoop == 1)
//    {
//
//        #if CLLLC_SFRA_TYPE == CLLLC_SFRA_DISABLED
//            CLLLC_gvError = (CLLLC_vPrimRefSlewed_pu - CLLLC_vPrimSensed_pu);
//        #else
//            CLLLC_gvError = (CLLLC_SFRA_INJECT(CLLLC_vPrimRefSlewed_pu) -
//                                      CLLLC_vPrimSensed_pu);
//        #endif
//
//        CLLLC_gvOut = CLLLC_GV_IMMEDIATE_RUN(&CLLLC_gv,
//                                       CLLLC_gvError,
//                                       CLLLC_gvPartialComputedValue);
//
//        if(CLLLC_gvOut > CLLLC_GV_OUT_MAX)
//        {
//            CLLLC_gvOut = CLLLC_GV_OUT_MAX;
//        }
//        if(CLLLC_gvOut < CLLLC_GV_OUT_MIN)
//        {
//            CLLLC_gvOut = CLLLC_GV_OUT_MIN;
//        }
//
//        CLLLC_gvPartialComputedValue = CLLLC_GV_PRECOMPUTE_RUN(&CLLLC_gv,
//                                                        CLLLC_gvError,
//                                                        CLLLC_gvOut);
//
//        if(CLLLC_gvOut < CLLLC_pwmPeriodMin_pu)
//        {
//            CLLLC_gvOut = CLLLC_pwmPeriodMin_pu;
//        }
//
//        CLLLC_pwmPeriod_pu = CLLLC_gvOut;
//    }
//    else
//    {
//
//        CLLLC_gi.d4 = CLLLC_pwmPeriod_pu;
//        CLLLC_gi.d5 = CLLLC_pwmPeriod_pu;
//        CLLLC_gi.d6 = CLLLC_pwmPeriod_pu;
//        CLLLC_gi.d7 = CLLLC_pwmPeriod_pu;
//
//        CLLLC_gv.d4 = CLLLC_pwmPeriod_pu;
//        CLLLC_gv.d5 = CLLLC_pwmPeriod_pu;
//        CLLLC_gv.d6 = CLLLC_pwmPeriod_pu;
//        CLLLC_gv.d7 = CLLLC_pwmPeriod_pu;
//
//        CLLLC_gvError = (CLLLC_vPrimRefSlewed_pu - CLLLC_vPrimSensed_pu);
//        CLLLC_gv.d0 = CLLLC_gvError;
//        CLLLC_gv.d1 = CLLLC_gvError;
//        CLLLC_gv.d2 = CLLLC_gvError;
//        CLLLC_gv.d3 = CLLLC_gvError;
//
//        CLLLC_gvPartialComputedValue = CLLLC_pwmPeriod_pu;
//
//        #if CLLLC_INCR_BUILD == CLLLC_OPEN_LOOP_BUILD
//            #if CLLLC_SFRA_TYPE == CLLLC_SFRA_DISABLED
//                //CLLLC_pwmPeriod_pu = CLLLC_pwmPeriodRef_pu;
//            #else
//                CLLLC_pwmPeriod_pu =
//                        CLLLC_SFRA_INJECT(CLLLC_pwmPeriodRef_pu);
//            #endif
//        #else
//            CLLLC_pwmPeriod_pu = CLLLC_pwmPeriodRef_pu;
//        #endif
//
//        if(CLLLC_pwmPeriod_pu < CLLLC_pwmPeriodMin_pu)
//        {
//            CLLLC_pwmPeriod_pu = CLLLC_pwmPeriodMin_pu;
//        }
//        else if(CLLLC_pwmPeriod_pu > 1.0f)
//        {
//            CLLLC_pwmPeriod_pu = 1.0f;
//        }
//    }
//
//    if(fabsf(CLLLC_pwmPeriod_pu - CLLLC_pwmPeriodSlewed_pu) >
//                            CLLLC_MAX_PERIOD_STEP_PU)
//    {
//        if(CLLLC_pwmPeriod_pu > CLLLC_pwmPeriodSlewed_pu)
//        {
//            CLLLC_pwmPeriodSlewed_pu = CLLLC_pwmPeriodSlewed_pu +
//                                        CLLLC_MAX_PERIOD_STEP_PU;
//        }
//        else
//        {
//            CLLLC_pwmPeriodSlewed_pu = CLLLC_pwmPeriodSlewed_pu -
//                                        CLLLC_MAX_PERIOD_STEP_PU;
//        }
//    }
//    else
//    {
//        CLLLC_pwmPeriodSlewed_pu = CLLLC_pwmPeriod_pu;
//    }
//
//    CLLLC_pwmFrequency_Hz = (CLLLC_PWMSYSCLOCK_FREQ_HZ /
//                             (CLLLC_pwmPeriodSlewed_pu *
//                              CLLLC_pwmPeriodMax_ticks));
//
//    #if CLLLC_SFRA_TYPE == CLLLC_SFRA_VOLTAGE
//        CLLLC_SFRA_COLLECT((float32_t *)&CLLLC_pwmPeriodSlewed_pu,
//                               (float32_t *)&CLLLC_vPrimSensed_pu);
//    #else
//        #ifndef __TMS320C28XX_CLA__
//
//        #if CLLLC_SFRA_TYPE == CLLLC_SFRA_DISABLED
//
//        #endif
//
//        #endif
//
//    #endif


    CLLLC_HAL_clearISR2PeripheralInterruptFlag();

    //
    // Only issue ISR1 if there is a change in the PWM
    //
    if((CLLLC_pwmFrequencyPrev_Hz != CLLLC_pwmFrequency_Hz) ||
       (CLLLC_pwmPhaseShiftPrimSec_ns != CLLLC_pwmPhaseShiftPrimSecRef_ns) ||
       (CLLLC_pwmDutyPrim_pu != CLLLC_pwmDutyPrimRef_pu) ||
       (CLLLC_pwmDutySec_pu != CLLLC_pwmDutySecRef_pu))
    {

        CLLLC_pwmDutyPrim_pu = CLLLC_pwmDutyPrimRef_pu;
        CLLLC_pwmDutySec_pu = CLLLC_pwmDutySecRef_pu;
        CLLLC_pwmPhaseShiftPrimSec_ns = CLLLC_pwmPhaseShiftPrimSecRef_ns;

        CLLLC_calculatePWMDutyPeriodPhaseShiftTicks_secToPrimPowerFlow();

        CLLLC_HAL_setupISR1Trigger(CLLLC_pwmFrequencyPrev_Hz);

        CLLLC_pwmFrequencyPrev_Hz = CLLLC_pwmFrequency_Hz;

        #if CLLLC_ISR1_RUNNING_ON == CLA_CORE
              CLLLC_pwmISRTrig_ticks =
                     ((TICKS_IN_PWM_FREQUENCY(CLLLC_pwmFrequency_Hz,
                                          CLLLC_PWMSYSCLOCK_FREQ_HZ)>> 1) - 20);
        #else
              CLLLC_pwmISRTrig_ticks =
                     ((TICKS_IN_PWM_FREQUENCY(CLLLC_pwmFrequency_Hz,
                                          CLLLC_PWMSYSCLOCK_FREQ_HZ)>> 1) - 27);
        #endif

    }
}



#ifdef __cplusplus
}
#endif                                  /* extern "C" */


#endif
